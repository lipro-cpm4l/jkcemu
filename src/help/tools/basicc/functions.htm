<html>
<body>
 <h1><a href="../basicc.htm">BASIC-Compiler</a></h1>

 <h2>Funktionen und Systemvariablen</h2>

 <h3>1. Datentyp des R&uuml;ckgabewertes</h3>
  Funktionen, die mit einem $-Zeichen enden,
  liefern eine Zeichenkette zur&uuml;ck.
  Alle anderen Funktionen haben einen numerischen R&uuml;ckgabewert.
 <br/><br/>

 <h3>2. Argumente</h3>
  Die Argumente bzw. Parameter werden in Klammern hinter
  dem Funktionsnamen geschrieben.
  Bei String-Funktionen ohne Argumente
  (z.B.&nbsp;<a href="functions.htm#inkey$">INKEY$</a>)
  entfallen diese Klammern.
 <br/><br/>

 <h3>3. Systemvariablen</h3>
  Systemvariablen sind wie Funktionen ohne Argumente.
  Sie k&ouml;nnen gelesen, nicht aber direkt beschrieben werden.
  Systemvariablen werden vom System gesetzt.
  Manche k&ouml;nnen auch mit Hilfe spezieller Anweisungen gesetzt werden
  (z.B. <a href="functions.htm#xpos">XPOS</a> und
  <a href="functions.htm#ypos">YPOS</a> durch die
  <a href="instructions.htm#move">MOVE</a>-Anweisung).
 <br/><br/>
  Da sich Systemvariablen f&uuml;r den Softwareentwickler wie
  Funktionen verhalten, werden sie hier in der Funktions&uuml;bersicht
  aufgef&uuml;hrt und beschrieben.
 <br/><br/>

 <h3>4. Beschreibung der einzelnen Funktionen</h3>
  <table border="1">
   <tr><th>Funktion</th><th>Bedeutung</th></tr>
   <tr valign="top">
    <td><a href="functions.htm#abs"><tt>ABS</tt></a></td>
    <td>Absoluter Betrag</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#asc"><tt>ASC</tt></a></td>
    <td>Zeichencode des ersten Zeichens einer Zeichenkette ermiteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#asm"><tt>ASM</tt></a></td>
    <td>Assemblerquelltext einf&uuml;gen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#available"><tt>AVAILABLE</tt></a></td>
    <td>Anzahl der im Eingabekanal verf&uuml;gbaren Bytes ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#bin$"><tt>BIN$</tt></a></td>
    <td>numerischen Wert in eine Bin&auml;rzahl umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#chr$"><tt>CHR$</tt></a></td>
    <td>Zeichencode in Zeichenkette umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#deek"><tt>DEEK</tt></a></td>
    <td>16-Bit-Wert (2&nbsp;Bytes) aus dem Arbeitsspeicher lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#dnsserver$"><tt>DNSSERVER$</tt></a></td>
    <td>IP-Adresse des DNS-Servers ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#eof"><tt>EOF</tt></a></td>
    <td>Ende eines Eingabekanals bzw. einer Datei erkennen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#err"><tt>ERR</tt></a></td>
    <td>Letzten Fehlercode ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#err$"><tt>ERR$</tt></a></td>
    <td>Letzten Fehlertext ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#gateway$"><tt>GATEWAY$</tt></a></td>
    <td>IP-Adresse des Gateways ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#hex$"><tt>HEX$</tt></a></td>
    <td>numerischen Wert in eine Hexadezimalzahl umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#hostbyname$"><tt>HOSTBYNAME$</tt></a></td>
    <td>IP-Adresse anhand des Hostnamens ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#h_char"><tt>H_CHAR</tt></a></td>
    <td>
     Bildschirmh&ouml;he in Zeichenpositionen (Anzahl Textzeilen) ermitteln
    </td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#h_pixel"><tt>H_PIXEL</tt></a></td>
    <td>Bildschirmh&ouml;he in Pixel ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#in"><tt>IN</tt></a></td>
    <td>Wert von einem Eingabetor lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#inkey$"><tt>INKEY$</tt></a></td>
    <td>Tastaturstatus abfragen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#in"><tt>INP</tt></a></td>
    <td>Wert von einem Eingabetor lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#input$"><tt>INPUT$</tt></a></td>
    <td>
     Tastatureingaben ohne Echo oder Bytes aus einem Eingabekanal
     bzw. einer Datei lesen
    </td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#instr"><tt>INSTR</tt></a></td>
    <td>Zeichenkette in einer anderen Zeichenkette suchen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#joyst"><tt>JOYST</tt></a></td>
    <td>Joystick abfragen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#left$"><tt>LEFT$</tt></a></td>
    <td>Anfang einer Zeichenkette extrahieren</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#len"><tt>LEN</tt></a></td>
    <td>L&auml;nge einer Zeichenkette ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#localaddr$"><tt>LOCALADDR$</tt></a></td>
    <td>Eigene IP-Adresse ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#localport"><tt>LOCALPORT</tt></a></td>
    <td>Lokale Portnummer ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#lower$"><tt>LOWER$</tt></a></td>
    <td>Zeichenkette in Kleinbuchstaben wandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ltrim$"><tt>LTRIM$</tt></a></td>
    <td>F&uuml;hrende wei&szlig;e Leerzeichen abschneiden</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#macaddr$"><tt>MACADDR$</tt></a></td>
    <td>MAC-Adresse ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#max"><tt>MAX</tt></a></td>
    <td>Gr&ouml;&szlig;ter Wert aus einer Liste von Werten ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#memstr$"><tt>MEMSTR$</tt></a></td>
    <td>auf eine im Arbeitsspeicher liegende Zeichenkette zugreifen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#mid$"><tt>MID$</tt></a></td>
    <td>Teilzeichenkette aus einer Zeichenkette extrahieren</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#min"><tt>MIN</tt></a></td>
    <td>Kleinster Wert aus einer Liste von Werten ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#mirror$"><tt>MIRROR$</tt></a></td>
    <td>Zeichenkette spiegeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#netmask$"><tt>NETMASK$</tt></a></td>
    <td>Netzwerkmaske ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#peek"><tt>PEEK</tt></a></td>
    <td>8-Bit-Wert (1&nbsp;Byte) aus dem Arbeitsspeicher lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#point"><tt>POINT</tt></a></td>
    <td>Testen eines Pixels</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ptest"><tt>PTEST</tt></a></td>
    <td>Testen eines Pixels</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#remoteaddr$"><tt>REMOTEADDR$</tt></a></td>
    <td>IP-Adresse der Gegenstelle ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#remoteport"><tt>REMOTEPORT</tt></a></td>
    <td>Portnummer der Gegenstelle ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#right$"><tt>RIGHT$</tt></a></td>
    <td>Ende einer Zeichenkette extrahieren</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#rnd"><tt>RND</tt></a></td>
    <td>Ermitteln einer Zufallszahl</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#rtrim$"><tt>RTRIM$</tt></a></td>
    <td>angeh&auml;ngte wei&szlig;e Leerzeichen abschneiden</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#sgn"><tt>SGN</tt></a></td>
    <td>Ermitteln des Vorzeichens</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#space$"><tt>SPACE$</tt></a></td>
    <td>mit Leerzeichen gef&uuml;llte Zeichenkette erzeugen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#sqr"><tt>SQR</tt></a></td>
    <td>Ermitteln der Quadratwurzel</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#str$"><tt>STR$</tt></a></td>
    <td>numerischen Wert in eine Dezimalzahl umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#string$"><tt>STRING$</tt></a></td>
    <td>Zeichen oder Zeichenkette vervielf&auml;ltigen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#targetid$"><tt>TARGETID$</tt></a></td>
    <td>Zielsystem ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#trim$"><tt>TRIM$</tt></a></td>
    <td>wei&szlig;e Leerzeichen abschneiden</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#upper$"><tt>UPPER$</tt></a></td>
    <td>Zeichenkette in Gro&szlig;buchstaben wandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#usr"><tt>USR</tt></a></td>
    <td>In Maschinencode implementierte Funktion aufrufen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#val"><tt>VAL</tt></a></td>
    <td>Zeichenkette in einen numerischen Wert umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#w_char"><tt>W_CHAR</tt></a></td>
    <td>
     Bildschirmbreite in Zeichenpositionen (Anzahl Textspalten) ermitteln
    </td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#w_pixel"><tt>W_PIXEL</tt></a></td>
    <td>Bildschirmbreite in Pixel ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#xpos"><tt>XPOS</tt></a></td>
    <td>aktuelle X-Koordinate des Grafikcursors ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#yellow"><tt>YELLOW</tt></a></td>
    <td>Nummer der Farbe gelb ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ypos"><tt>YPOS</tt></a></td>
    <td>aktuelle Y-Koordinate des Grafikcursors ermitteln</td>
   </tr>
  </table>
 <br/><br/>

 <h3>Erl&auml;uterungen zu den Funktionen</h3>
  In spitzen Klammern eingeschlossene Elemente dienen als Platzhalter
  und sind entsprechend zu ersetzten.
 <br/><br/>

 <h3><a name="abs">ABS</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>ABS</tt> <tt>(</tt> &lt;numerischer Ausdruck&gt; <tt>)</tt></td>
   </tr>
  </table>
 <br/>
   Die Funktion liefert den absoluten Betrag des Wertes
   des angegebenen Ausdrucks.
 <br/><br/>

 <h3><a name="asc">ASC</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>ASC (</tt> &lt;Zeichenkette&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
   Die Funktion liefert den Code des ersten Zeichens
   in der &uuml;bergebenen Zeichenkette.
   Ist die Zeichenkette leer, wird 0 zur&uuml;ckgegeben.
 <br/><br/>

 <h3><a name="asm">ASM</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td nowrap="nowrap">
     <tt>ASM (</tt> &lt;Zeichenkette&gt;
     [, &lt;Zeichenkette&gt; [, ...]] <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>String-Literal</td></tr>
  </table>
 <br/>
  Die ASM-Funktion f&uuml;gt in den vom Compiler erzeugten Assemblertext
  eine oder mehrere Assemblerzeilen ein.
  Im Gegensatz zur <a href="instructions.htm#asm">ASM</a>-Anweisung
  wird bei der ASM-Funktion der Wert im HL-Register an das BASIC-Programm
  zur&uuml;ckgegeben.
  In Verbindung mit der <a href="functions.htm#memstr$">MEMSTR$</a>-Funktion
  lassen sich auch in eigenen Assembler-Routinen
  erzeugte Zeichenketten an das BASIC-Programm zur&uuml;ckgeben.
 <br/><br/>
  Das Beispiel zeigt eine m&ouml;gliche Anwendung der ASM-Funktion
  in Verbindung mit <a href="functions.htm#usr">USR</a>,
  um auf diese Art und Weise einen Parameter an die Assembler-Routine
  zu &uuml;bergeben und einen numerischen Wert zur&uuml;ckgaben zu lassen:
 <br/><br/>
  <tt>
   DEF USR0 = ASM(" LD HL,meine_negation")<br/>
   PRINT USR0(123)<br/>
   END<br/>
   <br/>
   ASM "meine_negation:"<br/>
   ASM " LD HL,0000H"<br/>
   ASM " OR A"<br/>
   ASM " SBC HL,DE"<br/>
   ASM " RET"
  </tt>
 <br/><br/>
  Im zweiten Beispiel liefert die Assembler-Routine die Zeichenkette
  <em>ABC</em> zur&uuml;ck:
 <br/><br/>
  <tt>
   PRINT MEMSTR$( ASM$(" CALL meine_routine") )<br/>
   END<br/>
   <br/>
   ASM CODE "meine_routine:"<br/>
   ASM CODE " LD HL,mein_string"<br/>
   ASM CODE " RET"<br/>
   ASM DATA "mein_string: DB 'ABC',0"
  </tt>
 <br/><br/>
  <b>Achtung!</b> Diese ASM-Funktion greift direkt
  in die Programmcodeerzeugung ein und ist deshalb nur
  f&uuml;r Experten gedacht, die genau wissen, was sie tun!
 <br/><br/>

 <h3><a name="available">AVAILABLE</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>AVAILABLE</tt> <tt>(</tt> &lt;Kanal&gt; <tt>)</tt><br/>
     <tt>AVAILABLE</tt> <tt>( #</tt> &lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt die Anzahl der im Eingabekanal verf&uuml;gbaren
  Bytes, die ohne zu warten gelesen werden k&ouml;nnen.
  Bei einer Netzwerkkommunikation bedeutet das die Anzahl
  der empfangenen Bytes, die noch nicht gelesen wurden.
  Beim Lesen von einer Datei liefert die Funktion die Anzahl der Bytes
  im Puffer, d.h., die Bytes,
  die ohne Zugriff auf das Speichermedium gelesen werden k&ouml;nnen.
 <br/><br/>
  Die Funktion setzt die Fehlervariablen
  <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a>.
 <br/><br/>

 <h3><a name="bin$">BIN$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>BIN$</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt><br/>
     <tt>BIN$</tt> <tt>(</tt> &lt;Wert&gt;
	<tt>,</tt> &lt;Anzahl Stellen&gt; <tt>)</tt><br/>
    </td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Anzahl Stellen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion BIN$ erzeugt eine Zeichenkette,
  die den &uuml;bergebenen Wert als Bin&auml;rzahl darstellt.
  Wird das zweite Argument weggelassen oder dieses ist Null,
  dann richtet sich die Anzahl der Stellen,
  d.h. die L&auml;nge der erzeugten Zeichenkette,
  nach der Gr&ouml;&szlig;e des &uuml;bergebenen Wertes.
 <br/><br/>

 <h3><a name="chr$">CHR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>CHR$</tt> <tt>(</tt> &lt;Zeichencode&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichencode:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion CHR$ erzeugt eine Zeichenkette,
  die nur aus dem einen Zeichen besteht,
  welches dem &uuml;bergebenen Zeichencode
  (i.d.R.&nbsp;ASCII-Code) entspricht.
  Wird der Wert Null &uuml;bergeben, ist die zur&uuml;ckgelieferte
  Zeichenkette leer.
 <br/><br/>
  <b>Achtung!</b> Bei den Anweisungen
  <a href="instructions.htm#print">PRINT</a> und
  <a href="instructions.htm#lprint">LPRINT</a> wird mit <tt>CHR$(0)</tt>
  ein Null-Byte ausgegegen.
 <br/><br/>

 <h3><a name="deek">DEEK</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td> <tt>DEEK</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt></td>
   </tr>
   <tr valign="top">
    <td>Adresse:</td><td>numerischer Ausdruck</td>
   </tr>
  </table>
 <br/>
  Die Funktion liest zwei aufeinander folgende Bytes vom Arbeitsspeicher
  ab der angegebenen Adresse und liefert sie als 16-Bit-Wert zur&uuml;ck.
 <br/><br/>

 <h3><a name="dnsserver$">DNSSERVER$</a></h3>
  Die Funktion liefert die im KCNet eingetragene IP-Adresse
  des DNS-Servers zur&uuml;ck.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="eof">EOF</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>EOF</tt> <tt>(</tt> &lt;Kanal&gt; <tt>)</tt><br/>
     <tt>EOF</tt> <tt>( #</tt> &lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion testet,
  ob das Ende des Eingabekanals bzw. der Datei erreicht wurde.
  Dabei werden die Fehlervariablen&nbsp;<a href="functions.htm#err">ERR</a>
  und <a href="functions.htm#err$">ERR$</a> gesetzt.
 <br/><br/>

 <h3><a name="err">ERR</a></h3>
  Die Systemvariable ERR enth&auml;lt den letzten Fehlercode.
  Der Wert&nbsp;0 (Konstante&nbsp;E_OK) bedeutet,
  dass bei der letzten Anweisung oder Funktion,
  die die Fehlervariable gesetzt hat, kein Fehler aufgetreten ist.
  Ein Wert ungleich Null steht f&uuml;r einen Fehler.
  Zum Auswerten der Fehlervariable&nbsp;ERR gibt es
  <a href="constants.htm#error">Fehlercodekonstanten</a>.
 <br/><br/>

 <h3><a name="err$">ERR$</a></h3>
  Die Systemvariable ERR$ enth&auml;lt den letzten Fehlertext.
  In Verbindung mit der Systemvariable&nbsp;ERR
  kann die Fehlerbehandlung recht einfach und f&uuml;r den Anwender
  trotzdem komfortabel gestaltet werden, z.B.:
 <br/><br/>
  <tt>
   ...:'Funktion oder Anweisung, die die Fehlervariablen setzt<br/>
   IF ERR THEN<br/>
   &nbsp; PRINT ERR$<br/>
   ELSE<br/>
   ...:'kein Fehler aufgetreten<br/>
   ENDIF
  </tt>
 <br/><br/>
  <b>Achtung!</b> Wenn Sie die Systemvariable&nbsp;ERR$ verwenden,
  wird das compilierte Programm entsprechend gr&ouml;&szlig;er,
  da alle Fehlermeldungen, die auftreten k&ouml;nnen,
  auch in das Programm hineincompiliert werden m&uuml;ssen.
  Wenn Sie ein m&ouml;glichst kleines Programm anstreben
  und auf die detaillierten Fehlertexte verzichten k&ouml;nnen,
  sollten Sie nur die Fehlercodevariable&nbsp;ERR verwenden,
  und nicht ERR$.
 <br/><br/>

 <h3><a name="gateway$">GATEWAY$</a></h3>
  Die Funktion liefert die im KCNet eingetragene IP-Adresse
  des Gateways zur&uuml;ck.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="hex$">HEX$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>HEX$</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt><br/>
     <tt>HEX$</tt> <tt>(</tt> &lt;Wert&gt;
	<tt>,</tt> &lt;Anzahl Stellen&gt; <tt>)</tt><br/>
    </td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Anzahl Stellen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion HEX$ erzeugt eine Zeichenkette,
  die den &uuml;bergebenen Wert als Hexadezimalzahl darstellt.
  Wird das zweite Argument weggelassen oder dieses ist Null,
  dann richtet sich die Anzahl der Stellen,
  d.h. die L&auml;nge der erzeugten Zeichenkette,
  nach der Gr&ouml;&szlig;e des &uuml;bergebenen Wertes.
 <br/><br/>

 <h3><a name="hostbyname$">HOSTBYNAME$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>HOSTBYNAME$</tt> <tt>(</tt> &lt;Hostname&gt; <tt>)
    </td>
   </tr>
   <tr><td>Hostname:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion ermittelt die IP-Adresse zu dem &uuml;bergebenen
  Rechnernamen.
  Dazu wird der im KCNet eingetragene DNS-Server angefragt.
  Als Rechnername kann auch eine IP-Adresse in der &uuml;blichen
  Schreibweise &uuml;bergeben werden.
  In dem Fall wird der DNS-Server nicht angefragt,
  sondern die &uuml;bergebene IP-Adresse ohne eventuell f&uuml;hrende
  und angeh&auml;ngten Leerzeichen zur&uuml;ckgegeben.
  Die Funktion setzt die Fehlervariablen
  <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a>.
 <br/><br/>

 <h3><a name="h_char">H_CHAR</a></h3>
  Die Systemvariable enth&auml;lt die H&ouml;he des Bildschirms
  in Zeichenpositionen, d.h.,
  es wird die Anzahl der sichtbaren Textzeilen zur&uuml;ckgeliefert.
  Wenn dieser Wert nicht eindeutig feststeht bzw. bei dem Zielsystem
  unterschiedliche Werte m&ouml;glich sind (z.B. bei CP/M),
  enth&auml;lt die Variable den Wert&nbsp;-1.
 <br/><br/>
  Eine&nbsp;0 wird zur&uuml;ckgegeben, wenn mit der
  <a href="instructions.htm#screen">SCREEN</a>-Anweisung
  ein Grafikbildschirm eingestellt wurde,
  der keine Textausgaben zul&auml;sst.
 <br/><br/>

 <h3><a name="h_pixel">H_PIXEL</a></h3>
  Diese Systemvariable enth&auml;lt die H&ouml;he
  des vollgrafikf&auml;higen Bildschirms in Pixel.
  Steht keine Vollgrafik zur Verf&uuml;gung,
  liefert die H_PIXEL&nbsp;0 zur&uuml;ck.
  In dem Fall k&ouml;nnen die Grafikbefehle nicht verwendet werden.
 <br/><br/>

 <h3><a name="inkey$">INKEY$</a></h3>
  Die Funktion pr&uuml;ft, ob gerade eine Taste gedr&uuml;ckt ist.
  Wenn ja, liefert die Funktion eine Zeichenkette mit dem eingegebenen
  Zeichen zur&uuml;ck.
  Anderenfalls wird eine leere Zeichenkette zur&uuml;ckgegeben.
  INKEY$ hat keine Argumente.
 <br/><br/>

 <h3><a name="in">IN<br/>INP</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>IN</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt><br/>
     <tt>INP</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top"><td>Adresse:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktionen IN und INP haben die gleiche Wirkung.
  Sie lesen ein Byte von dem durch die Adresse
  angegebenen Eingabetor und liefern den Wert des Bytes zur&uuml;ck.
 <br/><br/>

 <h3><a name="input$">INPUT$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>INPUT$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>)</tt><br/>
     <tt>INPUT$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>,</tt>
		&lt;Kanal&gt; <tt>)</tt><br/>
     <tt>INPUT$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>, #</tt>
		&lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Anzahl:</td>
    <td>numerischer Ausdruck im Bereich 0 bis 255</td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion gibt es in zwei Varianten, mit und ohne Kanalnummer.
  In der Variante ohne Kanalnummer wird die angegebene Anzahl von Zeichen
  von der Tastatur gelesen und als Zeichenkette zur&uuml;ckgegeben.
  Steuertasten (z.B. Cursor-Tasten, Enter) werden nicht ausgewertet.
  Stattdessen finden sich die entsprechenden Steuercodes
  in der Zeichenkette wieder.
  Es erfolgt keine Ausgabe auf dem Bildschirm.
 <br/><br/>
  In der Variante mit Kanalnummer liest die Funktion
  die angegebene Anzahl von Zeichen aus dem Eingabekanal
  bzw. der Datei und gibt diese als Zeichenkette zur&uuml;ck.
  Dabei werden die Fehlervariablen <a href="functions.htm#err">ERR</a>
  und <a href="functions.htm#err$">ERR$</a> gesetzt.
 <br/><br/>
  <b>Achtung!</b> Null-Bytes dienen bei Zeichenketten als Endezeichen,
  d.h., wenn ein Null-Byte gelesen wird, enth&auml;lt die
  zur&uuml;ckgelieferte Zeichenkette nur die Bytes bis zum ersten
  gelesenen Null-Byte.
  Es werden aber trotzdem soviele Bytes aus dem Eingabekanal gelesen,
  wie im ersten Argument &uuml;bergeben wurde.
  Wenn also die zur&uuml;ckgelieferte Zeichenkette k&uuml;rzer ist
  als die Anzahl der gelesenen Bytes und in der Fehlervariable
  <a href="functions.htm#err">ERR</a> steht der Wert&nbsp;0
  (Konstante E_OK, kein Fehler aufgetreten),
  dann wurde hinter der Zeichenkette ein Null-Byte gelesen.
  Damit ist auch generell das Lesen von Bin&auml;rdateien m&ouml;glich.
  Das Beispiel zeigt, wie eine Datei Byte f&uuml;r Byte
  in die Variable&nbsp;<em>B</em> eingelesen wird:
 <br/><br/>
  <tt>
   OPEN "Datei" FOR INPUT AS #1<br>
   IF ERR THEN<br/>
   &nbsp; PRINT ERR$<br/>
   ELSE<br/>
   &nbsp; WHILE NOT EOF(#1)<br/>
   &nbsp; &nbsp; B=ASC(INPUT$(1,#1))<br/>
   &nbsp; &nbsp; IF ERR THEN EXIT<br/>
   &nbsp; &nbsp; ...:'mit dem gelesenen Byte etwas tun<br/>
   &nbsp; WEND<br/>
   &nbsp; IF ERR THEN PRINT ERR$<br/>
   &nbsp; CLOSE #1<br/>
   ENDIF
  </tt>
 <br/><br/>

 <h3><a name="instr">INSTR</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>INSTR</tt> <tt>(</tt> &lt;durchsuchte Zeichenkette&gt;
	<tt>,</tt> &lt;gesuchte Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr>
    <td>durchsuchte Zeichenkette:</td>
    <td>einfacher String-Ausdruck</td>
   </tr>
   <tr>
    <td>gesuchte Zeichenkette:</td>
    <td>einfacher String-Ausdruck</td>
   </tr>
  </table>
 <br/>
  Die Funktionen sucht im ersten Argument die Zeichenkette,
  die im zweiten Argument &uuml;bergeben wurde
  und gibt die Position der Fundstelle zur&uuml;ck.
  Ist die zweite Zeichenkette in der ersten nicht enthalten,
  wird 0 zur&uuml;ckgegeben.
 <br/><br/>
  Beispiel:
 <br/><br/>
  <tt>PRINT INSTR("ABCD","C")</tt>
 <br/><br/>
  liefert&nbsp;3.
 <br/><br/>
  <b>Achtung!</b> Bei dieser Funktion gibt es zwischen den einzelnen
  BASIC-Dialekten Unterschiede in der Argumentreihenfolge.
  Bei den meisten der international &uuml;blichen BASIC-Dialekte wird
  im ersten Argument die durchsuchte und im zweiten Argument
  die gesuchte Zeichenkette erwartet.
  Aus diesem Grund ist das auch in JKCEMU so realisiert.
  Beim KC-BASIC ist das dagegen genau anders herum.
  Wenn Sie also KC-BASIC-Programme compilieren bzw. portieren m&ouml;chten,
  m&uuml;ssen Sie die beiden Argumente vertauschen.
 <br/><br/>

 <h3><a name="joyst">JOYST</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>JOYST</tt> <tt>(</tt> &lt;Joystick-Nummer&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Joystick-Nummer:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
  </table>
 <br/>
  Die Funktionen liest den aktuellen Status des angegebenen Joysticks.
  Der erste Joystick hat die Nummer&nbsp;0.
  Der R&uuml;ckgabewert hat folgende Bedeutung:
 <br/><br/>
  <table border="1">
   <tr><th>Wert</th><th>Bedeutung</th></tr>
   <tr>
    <td>0</td>
    <td>Joystick nicht bet&auml;tigt oder nicht angeschlossen</td>
   </tr>
   <tr>
    <td>1</td>
    <td>Joystick nach links gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td>2</td>
    <td>Joystick nach rechts gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td>4</td>
    <td>Joystick nach unten gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td>8</td>
    <td>Joystick nach oben gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td>16</td>
    <td>Aktionsknopf&nbsp;1 gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td>32</td>
    <td>Aktionsknopf&nbsp;2 gedr&uuml;ckt (falls vorhanden)</td>
   </tr>
  </table>
 <br/>
  Zwischenstellungen werden durch die Addition der einzelnen Werte
  ausgedr&uuml;ckt.
  So bedeutet z.B. der Wert&nbsp;21, dass der Joystick nach
  links unten und gleichzeitig der Aktionsknopf&nbsp;1
  gedr&uuml;ckt ist ((1=links) + (4=unten) + (16=Aktionsknopf) = 21).
  Mit dem AND-Operator lassen sich die Einzelaktionen extrahieren:
 <br/><br/>
  <tt>
   A=JOYST(0)<br/>
   IF A AND 1 THEN PRINT "links"<br/>
   IF A AND 2 THEN PRINT "rechts"<br/>
   IF A AND 4 THEN PRINT "ab"<br/>
   IF A AND 8 THEN PRINT "auf"<br/>
   IF A AND 16 THEN PRINT "Feuer 1"<br/>
   IF A AND 32 THEN PRINT "Feuer 2"<br/>
   IF A AND 48 THEN PRINT "Feuer 1 oder 2"
  </tt>
 <br/><br/>
  Auf Systemen, die keine Joystick-Unterst&uuml;tzung bieten,
  liefert die JOYST-Funktion immer&nbsp;0.
 <br/><br/>

 <h3><a name="left$">LEFT$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LEFT$</tt> <tt>(</tt> &lt;Zeichenkette&gt;
	<tt>,</tt> &lt;Anzahl Zeichen&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr><td>Anzahl Zeichen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LEFT$ extrahiert aus der &uuml;bergebenen Zeichenkette
  eine Teilzeichenkette, die aus den linken <em>Anzahl Zeichen</em> besteht.
 <br/><br/>

 <h3><a name="len">LEN</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LEN</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion liefert die L&auml;nge der &uuml;bergebenen Zeichenkette
  zur&uuml;ck.
 <br/><br/>
  <b>Achtung!</b> Bei Zeichenketten, die mehr als 32767&nbsp;Zeichen
  enthalten, ist der R&uuml;ckgabewert kleiner Null!
  Die interne String-Verarbeitung kann zwar so lange Zeichenketten nicht
  erzeugen, aber mit der Funktion
  <a href="functions.htm#memstr">MEMSTR$</a> sind &uuml;berlange
  Zeichenketten prinzipiell m&ouml;glich.
 <br/><br/>

 <h3><a name="localaddr$">LOCALADDR$</a></h3>
  Die Funktion liefert die im KCNet eingetragene lokale,
  d.h. eigene, IP-Adresse zur&uuml;ck.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="localport">LOCALPORT</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LOCALPORT</tt> <tt>(</tt> &lt;Kanal&gt; <tt>)</tt><br/>
     <tt>LOCALPORT</tt> <tt>( #</tt> &lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt die lokale Portnummer,
  die der Kanal verwendet.
  Der Aufruf ist nur erlaubt, wenn der Kanal mit.
  <a href="instructions.html#accept">ACCEPT</a>,
  <a href="instructions.html#connect">CONNECT</a> oder
  <a href="instructions.html#datagram">DATAGRAM</a> ge&ouml;ffnet wurde.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="lower$">LOWER$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LOWER$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LOWER$ wandelt in der &uuml;bergebenen Zeichenkette
  die gro&szlig;en Buchstaben entsprechend dem ASCII-Zeichensatz in kleine um
  und liefert die umgewandelte Zeichenkette zur&uuml;ck.
  Eventuell vorhandene deutsche Umlaute bleiben unver&auml;ndert.
 <br/><br/>

 <h3><a name="ltrim$">LTRIM$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LTRIM$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LTRIM$ liefert eine Teilzeichenkette,
  die mit dem ersten Zeichen beginnt,
  welches kein Leer- oder Steuerzeichen ist.
  Es werden somit die f&uuml;hrenden wei&szlig;en Leerzeichen abgeschnitten.
 <br/><br/>

 <h3><a name="macaddr$">MACADDR$</a></h3>
  Die Funktion liefert die MAC-Adresse des KCNet-Moduls zur&uuml;ck.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="max">MAX</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>MAX</tt>
     <tt>(</tt>
     &lt;numerischer Ausdruck&gt;
     <tt>,</tt>
     &lt;numerischer Ausdruck&gt;
     [ <tt>,</tt> &lt;numerischer Ausdruck&gt; [ , ... ] ]
     <tt>)</tt>
    </td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert den gr&ouml;&szlig;ten der in der Argumentliste
  angegebenen Werte zur&uuml;ck.
 <br/><br/>

 <h3><a name="memstr$">MEMSTR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>MEMSTR$</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Adresse:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion MEMSTR$ erm&ouml;glicht es, eine an der angegebenen Adresse
  im Arbeitsspeicher befindliche Zeichenkette als BASIC-String zu verwenden.
  Ein Null-Byte markiert das Ende der Zeichenkette.
  Folgendes Beispiel erzeugt im Arbeitsspeicher eine Zeichenkette
  mit dem Alphabet, auf die dann mit MEMSTR$ zugegriffen wird:
 <br/><br/>
  <tt>
   A=TOP<br/>
   FOR I=65 TO 90<br/>
   &nbsp;POKE A,I<br/>
   &nbsp;A=A+1<br/>
   NEXT I<br/>
   POKE A,0<br/>
   PRINT MEMSTR$(TOP)
  </tt>
 <br/><br/>

 <h3><a name="mid$">MID$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>MID$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>,</tt>
	&lt;Position&gt; <tt>)</tt><br/>
     <tt>MID$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>,</tt>
	&lt;Position&gt; <tt>,</tt> &lt;Anzahl Zeichen&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr><td>Position:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Anzahl Zeichen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion MID$ extrahiert aus der &uuml;bergebenen Zeichenkette
  ab der angegebenen Position eine Teilzeichenkette
  und liefert diese zur&uuml;ck.
  Wird das dritte Argument angegeben, ist die Teilzeichenkette maximal
  <em>Anzahl Zeichen</em> lang.
  Anderenfalls geht die Teilzeichenkette bis zum Ende der Zeichenkette.
 <br/><br/>

 <h3><a name="min">MIN</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>MIN</tt>
     <tt>(</tt>
     &lt;numerischer Ausdruck&gt;
     <tt>,</tt>
     &lt;numerischer Ausdruck&gt;
     [ <tt>,</tt> &lt;numerischer Ausdruck&gt; [ , ... ] ]
     <tt>)</tt>
    </td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert den kleinsten der in der Argumentliste
  angegebenen Werte zur&uuml;ck.
 <br/><br/>

 <h3><a name="mirror$">MIRROR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>MIRROR$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion MIRROR$ liefert ein gespiegeltes Abbild der
  &uuml;bergebenen Zeichenkette zur&uuml;ck, d.h.,
  das letzte Zeichen in der &uuml;bergebenen Zeichenkette
  ist das erste Zeichen in der zur&uuml;ckgelieferten.
 <br/><br/>

 <h3><a name="netmask$">NETMASK$</a></h3>
  Die Funktion liefert die im KCNet eingetragene Netzwerkmaske zur&uuml;ck.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="peek">PEEK</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>PEEK</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt></td>
   </tr>
   <tr valign="top"><td>Adresse:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion liest das Byte vom Arbeitsspeicher,
  welches auf der angegebenen Adresse steht,
  und liefert den Wert des Bytes zur&uuml;ck.
 <br/><br/>

 <h3><a name="point">POINT</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>POINT</tt> <tt>(</tt> &lt;X&gt; <tt>,</tt> &lt;Y&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>X:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
   <tr valign="top">
    <td>Y:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt den Zustand eines Pixels.
  Ist das Pixel an der angegebenen Position gesetzt,
  wird 1 zur&uuml;ckgeliefert, bei nicht gesetztem Pixel eine&nbsp;0.
  Im Fehlerfall, d.h. wenn der angegebene Punkt au&szlig;erhalb
  des Bildschirms liegt oder keine Grafikumgebung vorhanden ist,
  wird -1 zur&uuml;ckgeliefert.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/><br/>
  Die POINT-Funktion ist identisch zur PTEST-Funktion.
  Der BASIC-Compiler unterst&uuml;tzt beide Funktionsnamen
  aus Gr&uuml;nden der Kompatibilit&auml;t zu diversen BASIC-Dialekten.
 <br/><br/>

 <h3><a name="ptest">PTEST</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>PTEST</tt> <tt>(</tt> &lt;X&gt; <tt>,</tt> &lt;Y&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>X:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
   <tr valign="top">
    <td>Y:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
  </table>
 <br/>
  Die Funktion testet ein Pixel und ist identisch zur POINT-Funktion.
  Der BASIC-Compiler unterst&uuml;tzt beide Funktionsnamen
  aus Gr&uuml;nden der Kompatibilit&auml;t zu diversen BASIC-Dialekten.
 <br/><br/>

 <h3><a name="remoteaddr$">REMOTEADDR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>REMOTEADDR$</tt> <tt>(</tt> &lt;Kanal&gt; <tt>)</tt><br/>
     <tt>REMOTEADDR$</tt> <tt>( #</tt> &lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt die IP-Adresse der Gegenstelle.
  Der Aufruf ist nur erlaubt, wenn der Kanal mit
  <a href="instructions.html#accept">ACCEPT</a>,
  <a href="instructions.html#connect">CONNECT</a> oder
  <a href="instructions.html#datagram">DATAGRAM</a> ge&ouml;ffnet wurde.
  Im Fall von DATAGRAM liefert die Funktion die Absenderadresse
  der zuletzt empfangenen Daten.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="remoteport">REMOTEPORT</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>REMOTEPORT</tt> <tt>(</tt> &lt;Kanal&gt; <tt>)</tt><br/>
     <tt>REMOTEPORT</tt> <tt>( #</tt> &lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt die Portnummer der Gegenstelle.
  Der Aufruf ist nur erlaubt, wenn der Kanal mit.
  <a href="instructions.html#accept">ACCEPT</a>,
  <a href="instructions.html#connect">CONNECT</a> oder
  <a href="instructions.html#datagram">DATAGRAM</a> ge&ouml;ffnet wurde.
  Im Fall von DATAGRAM liefert die Funktion die Absenderportnummer
  der zuletzt empfangenen Daten.
  Die Fehlervariablen <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a> werden gesetzt.
 <br/><br/>

 <h3><a name="right$">RIGHT$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>RIGHT$</tt> <tt>(</tt> &lt;Zeichenkette&gt;
	<tt>,</tt> &lt;Anzahl Zeichen&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr><td>Anzahl Zeichen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion RIGHT$ extrahiert aus der &uuml;bergebenen Zeichenkette
  eine Teilzeichenkette, die aus den rechten <em>Anzahl Zeichen</em> besteht.
 <br/><br/>

 <h3><a name="rnd">RND</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>RND</tt> <tt>(</tt> &lt;Maximalwert&gt; <tt>)</tt></td>
   </tr>
   <tr valign="top">
    <td>Maximalwert:</td>
    <td>numerischer Ausdruck mit Wert &gt;&nbsp;0</td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert einen zuf&auml;lligen Wert zwischen Null
  und dem angegebenen Maximalwert.
 <br/><br/>

 <h3><a name="rtrim$">RTRIM$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>RTRIM$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion RTRIM$ schneidet von der &uuml;bergebenen Zeichenkette
  am Ende stehende Leer- oder Steuerzeichen ab und liefert die so
  eventuell gek&uuml;rzte Zeichenkette zur&uuml;ck.
  Es werden somit die angeh&auml;ngten wei&szlig;en Leerzeichen abgeschnitten.
 <br/><br/>

 <h3><a name="sgn">SGN</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>SGN</tt> <tt>(</tt> &lt;numerischer Ausdruck&gt; <tt>)</tt></td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert -1, wenn der Wert des angegebenen Ausdrucks
  kleiner Null ist, 1 wenn der Wert gr&ouml;&szlig;er Null ist
  und Null, wenn der Wert Null ist.
 <br/><br/>

 <h3><a name="space$">SPACE$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>SPACE$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Anzahl:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion SPACE$ erzeugt eine Zeichenkette,
  die aus <em>Anzahl</em> Leerzeichen besteht.
 <br/><br/>

 <h3><a name="sqr">SQR</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>SQR</tt> <tt>(</tt> &lt;numerischer Ausdruck&gt; <tt>)</tt></td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert den ganzzahligen Anteil der Quadratwurzel
  aus dem Wert des angegebenen Ausdrucks zur&uuml;ck.
 <br/><br/>

 <h3><a name="str$">STR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>STR$</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion STR$ erzeugt eine Zeichenkette,
  die den &uuml;bergebenen Wert als Dezimalzahl darstellt.
  Das erste Zeichen der erzeugten Zeichenkette ist entweder
  ein Leer- oder ein Minuszeichen.
 <br/><br/>

 <h3><a name="string$">STRING$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>STRING$</tt> <tt>(</tt> &lt;Anzahl&gt;
	<tt>,</tt> &lt;Zeichencode&gt; <tt>)</tt><br/>
     <tt>STRING$</tt> <tt>(</tt> &lt;Anzahl&gt;
	<tt>,</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Anzahl:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Zeichencode:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion STRING$ liefert eine Zeichenkette zur&uuml;ck,
  die aus <em>Anzahl</em> Wiederholungen der &uuml;bergebenen Zeichenkette
  bzw. des mit seinem Code &uuml;bergebenen Zeichens besteht.
  Die Anzahl der Wiederholungen wird im ersten Argument &uuml;bergeben
  und kann auch Null sein.
  In dem Fall wird eine leere Zeichenkette zur&uuml;ckgeliefert.
 <br/><br/>

 <h3><a name="targetid$">TARGETID$</a></h3>
  Die Funktion TARGETID$ liefert eine Zeichenkette,
  die das Zielsystem identifiziert.
  Mit Hilfe dieser Zeichenkette kann ein BASIC-Programm portabel geschrieben
  und dabei trotzdem auf ganz spezifische Eigenheiten des Zielsystems
  angepasst werden.
  Folgendes Beispiel demonstriert die Anwendung:
 <br/><br/>
  <tt>
   IF TARGETID$="KC85" THEN PRINT "Farbe"<br/>
   IF INSTR(TARGETID$,"Z9001")&gt;0 THEN PRINT "Farbe optional"<br/>
   IF TARGETID$="Z1013" THEN PRINT "schwarz/weiss"
  </tt>
 <br/><br/>
  Welche Zeichenkette die einzelnen Zielsysteme liefern,
  finden Sie in den Hinweisen zu den <a href="targets.htm">Zielsystemen</a>.
 <br/><br/>
  <b>Achtung!</b> Das Zielsystem ist das System,
  f&uuml;r welches der Compiler den Programmcode erzeugt hat.
  Es muss nicht zwingend genau das System sein,
  auf dem das compilierte BASIC-Programm gerade ausgef&uuml;hrt wird.
  Wenn man z.B. ein Programm f&uuml;r das Zielsystem <em>Z9001_KRT</em>
  &uuml;bersetzt, kann man es auch auf einem Z9001 ohne KRT-Grafik starten.
  Probleme treten erst auf, wenn das Programm mit der SCREEN-Anweisung
  auf die KRT-Grafik umschaltet.
  Solange das jedoch nicht der Fall ist, also in Textmodus,
  ist das Programm lauff&auml;hig.
  TARGETID$ liefert in dem Fall &quot;Z9001_KRT&quot;,
  obwohl es auf einem Z9001 ohne KRT-Grafik ausgef&uuml;hrt wird.
 <br/><br/>
  Die Funktion TARGETID$ hat keine Argumente.
 <br/><br/>

 <h3><a name="trim$">TRIM$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>TRIM$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion TRIM$ schneidet von der &uuml;bergebenen Zeichenkette
  sowohl am Anfang als auch am Ende stehende Leer- oder Steuerzeichen ab
  und liefert die so eventuell gek&uuml;rzte Zeichenkette zur&uuml;ck.
  Es werden somit die f&uuml;hrenden und angeh&auml;ngten
  wei&szlig;en Leerzeichen abgeschnitten.
 <br/><br/>

 <h3><a name="upper$">UPPER$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>UPPER$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion UPPER$ wandelt in der &uuml;bergebenen Zeichenkette
  die kleinen Buchstaben entsprechend dem ASCII-Zeichensatz in gro&szlig;e um
  und liefert die umgewandelte Zeichenkette zur&uuml;ck.
  Eventuell vorhandene deutsche Umlaute bleiben unver&auml;ndert.
 <br/><br/>

 <h3><a name="usr">USR</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>USR</tt> &lt;Funktionsnummer&gt;
	<tt>(</tt> &lt;Argument&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Funktionsnummer:</td><td>0...9</td></tr>
   <tr><td>Argument:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Mit USR wird eine von 10 m&ouml;glichen Funktionen aufgerufen,
  die der Anwender in Maschinencode frei implementieren kann.
  Die Adresse muss vorher mit der Anweisung <tt>DEF&nbsp;USR</tt>
  festgelegt worden sein.
  Das Argument wird im DE-Register der Benutzerfunktion &uuml;bergeben.
  Die Benutzerfunktion selbst muss mit einem Return-Befehl abgeschlossen
  sein.
  Der Wert, der sich zum Funktionsende im HL-Register befindet,
  wird an das BASIC-Programm zur&uuml;ckgegeben.
 <br/><br/>
  Das Schl&uuml;sselwort <tt>USR</tt> und die Funktionsnummer k&ouml;nnen
  sowohl zusammen als auch getrennt geschrieben werden, z.B.:
 <br/><br/>
  <tt>
   PRINT USR 0 (123)<br/>
   PRINT USR0 (123)<br/>
   PRINT USR 0(123)<br/>
   PRINT USR0(123)
  </tt>
 <br/><br/>
  Im Gegensatz zur <a href="instructions.htm#call">CALL</a>-Anweisung
  kann man bei USR dem Maschinencodeunterprogramm einen Wert &uuml;bergeben
  und einen zur&uuml;ckgeben lassen.
 <br/><br/>

 <h3><a name="val">VAL</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>VAL</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt><br/>
     <tt>VAL</tt> <tt>(</tt> &lt;Zeichenkette&gt;
	<tt>,</tt> &lt;Zahlenbasis&gt; <tt>)</tt><br/>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr>
    <td>Zahlenbasis:</td>
    <td>numerischer Ausdruck mit dem Wert 2, 10 oder 16</td>
   </tr>
  </table>
 <br/>
  Die Funktion VAL versucht den Inhalt einer Zeichenkette
  als Zahl zu lesen und liefert deren numerischen Wert zur&uuml;ck.
  Wird eine Zahlenbasis angegeben, erwartet die Funktion entsprechend
  dieses Basis eine Bin&auml;r-, Dezimal- oder Hexadezimalzahl.
  Ohne dem zweiten Argument wird immer eine Dezimalzahl erwartet.
  Zahlen mit einer anderen Basis werden nicht unterst&uuml;tzt.
 <br/><br/>
  Bei Hexadezimalzahlen k&ouml;nnen die Buchstaben A bis F
  sowohl gro&szlig; als auch klein geschrieben sein.
 <br/><br/>
  Die VAL-Funktion setzt die Fehlervariablen
  <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a>.
  Damit, insbesondere mit der ERR-Variable, kann gepr&uuml;ft werden,
  ob die Funktion erfolgreich war:
  <table border="1">
   <tr><th>ERR-Wert</th><th>Bedeutung</th></tr>
   <tr>
    <td valign="top"><a href="constants.htm#error">E_OK</a></td>
    <td>Zahl konnte gelesen werden</td>
   </tr>
   <tr>
    <td valign="top"><a href="constants.htm#error">E_INVALID</a></td>
    <td>
     ung&uuml;ltige Zeichen gelesen,
     R&uuml;ckgabewert ist&nbsp;0
    </td>
   </tr>
   <tr>
    <td valign="top"><a href="constants.htm#error">E_OVERFLOW</a></td>
    <td>
     numerischer &Uuml;berlauf, d.h. die Zahl ist zu gro&szlig;,
     R&uuml;ckgabewert ist&nbsp;0
    </td>
   </tr>
  </table>
 <br/>
  Das Beispiel zeigt die VAL-Funktion in Verbindung mit der
  Fehlervariable&nbsp;ERR:
 <br/><br/>
  <tt>
   DO<br/>
   &nbsp; INPUT "Eingabe:";E$<br>
   &nbsp; V=VAL(E$,2)<br/>
   &nbsp; IF ERR=E_OK THEN PRINT "Binaerzahl, Dezimalwert=";V<br/>
   &nbsp; V=VAL(E$,10)<br/>
   &nbsp; IF ERR=E_OK THEN PRINT "Dezimalzahl, Dezimalwert=";V<br/>
   &nbsp; V=VAL(E$,16)<br/>
   &nbsp; IF ERR=E_OK THEN PRINT "Hexadezimalzahl, Dezimalwert=";V<br/>
   LOOP
  </tt>
 <br/><br/>

 <h3><a name="w_char">W_CHAR</a></h3>
  Die Systemvariable enth&auml;lt die Breite des Bildschirms
  in Zeichenpositionen, d.h.,
  es wird die Anzahl der sichtbaren Textspalten zur&uuml;ckgeliefert.
  Wenn dieser Wert nicht eindeutig feststeht bzw. bei dem Zielsystem
  unterschiedliche Werte m&ouml;glich sind (z.B. bei CP/M),
  wird -1 zur&uuml;ckgeliefert.
 <br/><br/>
  Eine&nbsp;0 wird zur&uuml;ckgegeben, wenn mit der
  <a href="instructions.htm#screen">SCREEN</a>-Anweisung
  ein Grafikbildschirm eingestellt wurde,
  der keine Textausgaben zul&auml;sst.
 <br/><br/>

 <h3><a name="w_pixel">W_PIXEL</a></h3>
  Die Systemvariable enth&auml;lt die Breite des vollgrafikf&auml;higen
  Bildschirms in Pixel.
  Steht keine Vollgrafik zur Verf&uuml;gung,
  liefert die Funktion&nbsp;0 zur&uuml;ck.
  In dem Fall k&ouml;nnen die Grafikbefehle nicht verwendet werden.
 <br/><br/>

 <h3><a name="xpos">XPOS</a></h3>
  Die Systemvariable enth&auml;lt die aktuelle X-Koordinate
  des Grafikcursors.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/><br/>

 <h3><a name="ypos">YPOS</a></h3>
  Die Systemvariable enth&auml;lt die aktuelle Y-Koordinate
  des Grafikcursors.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/>
</body>
</html>

