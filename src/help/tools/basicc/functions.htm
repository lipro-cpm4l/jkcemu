<html>
<body>
 <h1><a href="../basicc.htm">BASIC-Compiler</a></h1>

 <h2>Funktionen und Systemvariablen</h2>
  <ul>
   <li>
    <a href="functions.htm#ret_type">1. Datentyp des R&uuml;ckgabewertes</a>
   </li>
   <li><a href="functions.htm#func_args">2. Argumente</a></li>
   <li><a href="functions.htm#sys_vars">3. Systemvariablen</a></li>
   <li><a href="functions.htm#func_list">4. Liste der Funktionen</a></li>
   <li>
    <a href="functions.htm#func_descr">5. Beschreibung der Funktionen</a>
   </li>
  </ul>
 <br/>
  Der Compiler kennt folgende BASIC-Funktionen:
 <br/>
  &nbsp;<a href="functions.htm#abs"><tt>ABS</tt></a>
  &nbsp;<a href="functions.htm#asc"><tt>ASC</tt></a>
  &nbsp;<a href="functions.htm#asm"><tt>ASM</tt></a>
  &nbsp;<a href="functions.htm#bin$"><tt>BIN$</tt></a>
  &nbsp;<a href="functions.htm#chr$"><tt>CHR$</tt></a>
  &nbsp;<a href="functions.htm#deek"><tt>DEEK</tt></a>
  &nbsp;<a href="functions.htm#eof"><tt>EOF</tt></a>
  &nbsp;<a href="functions.htm#err"><tt>ERR</tt></a>
  &nbsp;<a href="functions.htm#err$"><tt>ERR$</tt></a>
  &nbsp;<a href="functions.htm#hex$"><tt>HEX$</tt></a>
  &nbsp;<a href="functions.htm#hibyte"><tt>HIBYTE</tt></a>
  &nbsp;<a href="functions.htm#h_char"><tt>H_CHAR</tt></a>
  &nbsp;<a href="functions.htm#h_pixel"><tt>H_PIXEL</tt></a>
  &nbsp;<a href="functions.htm#in"><tt>IN</tt></a>
  &nbsp;<a href="functions.htm#inkey$"><tt>INKEY$</tt></a>
  &nbsp;<a href="functions.htm#in"><tt>INP</tt></a>
  &nbsp;<a href="functions.htm#input$"><tt>INPUT$</tt></a>
  &nbsp;<a href="functions.htm#instr"><tt>INSTR</tt></a>
  &nbsp;<a href="functions.htm#is_target"><tt>IS_TARGET</tt></a>
  &nbsp;<a href="functions.htm#joyst"><tt>JOYST</tt></a>
  &nbsp;<a href="functions.htm#lcase$"><tt>LCASE$</tt></a>
  &nbsp;<a href="functions.htm#left$"><tt>LEFT$</tt></a>
  &nbsp;<a href="functions.htm#len"><tt>LEN</tt></a>
  &nbsp;<a href="functions.htm#lobyte"><tt>LOBYTE</tt></a>
  &nbsp;<a href="functions.htm#lower$"><tt>LOWER$</tt></a>
  &nbsp;<a href="functions.htm#ltrim$"><tt>LTRIM$</tt></a>
  &nbsp;<a href="functions.htm#max"><tt>MAX</tt></a>
  &nbsp;<a href="functions.htm#memstr$"><tt>MEMSTR$</tt></a>
  &nbsp;<a href="functions.htm#mid$"><tt>MID$</tt></a>
  &nbsp;<a href="functions.htm#min"><tt>MIN</tt></a>
  &nbsp;<a href="functions.htm#mirror$"><tt>MIRROR$</tt></a>
  &nbsp;<a href="functions.htm#peek"><tt>PEEK</tt></a>
  &nbsp;<a href="functions.htm#point"><tt>POINT</tt></a>
  &nbsp;<a href="functions.htm#ptest"><tt>PTEST</tt></a>
  &nbsp;<a href="functions.htm#right$"><tt>RIGHT$</tt></a>
  &nbsp;<a href="functions.htm#rnd"><tt>RND</tt></a>
  &nbsp;<a href="functions.htm#rtrim$"><tt>RTRIM$</tt></a>
  &nbsp;<a href="functions.htm#sgn"><tt>SGN</tt></a>
  &nbsp;<a href="functions.htm#space$"><tt>SPACE$</tt></a>
  &nbsp;<a href="functions.htm#sqr"><tt>SQR</tt></a>
  &nbsp;<a href="functions.htm#str$"><tt>STR$</tt></a>
  &nbsp;<a href="functions.htm#string$"><tt>STRING$</tt></a>
  &nbsp;<a href="functions.htm#trim$"><tt>TRIM$</tt></a>
  &nbsp;<a href="functions.htm#ucase$"><tt>UCASE$</tt></a>
  &nbsp;<a href="functions.htm#ucase$"><tt>UPPER$</tt></a>
  &nbsp;<a href="functions.htm#usr"><tt>USR</tt></a>
  &nbsp;<a href="functions.htm#val"><tt>VAL</tt></a>
  &nbsp;<a href="functions.htm#w_char"><tt>W_CHAR</tt></a>
  &nbsp;<a href="functions.htm#w_pixel"><tt>W_PIXEL</tt></a>
  &nbsp;<a href="functions.htm#xpos"><tt>XPOS</tt></a>
  &nbsp;<a href="functions.htm#ypos"><tt>YPOS</tt></a>
 <br/><br/>

 <h3><a name="ret_type">1. Datentyp des R&uuml;ckgabewertes</a></h3>
  Funktionen, die mit einem $-Zeichen enden,
  liefern eine Zeichenkette zur&uuml;ck.
  Alle anderen Funktionen haben einen numerischen R&uuml;ckgabewert.
 <br/><br/>

 <h3><a name="func_args">2. Argumente</a></h3>
  Die Argumente bzw. Parameter werden in Klammern hinter
  dem Funktionsnamen geschrieben.
  Bei String-Funktionen ohne Argumente
  (z.B.&nbsp;<a href="functions.htm#inkey$">INKEY$</a>)
  entfallen diese Klammern.
 <br/><br/>

 <h3><a name="sys_vars">3. Systemvariablen</a></h3>
  Systemvariablen sind wie Funktionen ohne Argumente.
  Sie k&ouml;nnen gelesen, nicht aber direkt beschrieben werden.
  Systemvariablen werden vom System gesetzt.
  Manche k&ouml;nnen auch mit Hilfe spezieller Anweisungen gesetzt werden
  (z.B. <a href="functions.htm#xpos">XPOS</a> und
  <a href="functions.htm#ypos">YPOS</a> durch die
  <a href="instructions.htm#move">MOVE</a>-Anweisung).
 <br/><br/>
  Da sich Systemvariablen f&uuml;r den Softwareentwickler wie
  Funktionen verhalten, werden sie hier in der Funktions&uuml;bersicht
  aufgef&uuml;hrt und beschrieben.
 <br/><br/>

 <h3><a name="func_list">4. Liste der Funktionen</a></h3>
  <table border="1">
   <tr><th>Funktion</th><th>Bedeutung</th></tr>
   <tr valign="top">
    <td><a href="functions.htm#abs"><tt>ABS</tt></a></td>
    <td>Absoluter Betrag</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#asc"><tt>ASC</tt></a></td>
    <td>Zeichencode des ersten Zeichens einer Zeichenkette ermiteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#asm"><tt>ASM</tt></a></td>
    <td>Assemblerquelltext einf&uuml;gen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#bin$"><tt>BIN$</tt></a></td>
    <td>numerischen Wert in eine Bin&auml;rzahl umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#chr$"><tt>CHR$</tt></a></td>
    <td>Zeichencode in Zeichenkette umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#deek"><tt>DEEK</tt></a></td>
    <td>16-Bit-Wert (2&nbsp;Bytes) aus dem Arbeitsspeicher lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#eof"><tt>EOF</tt></a></td>
    <td>Ende eines Eingabekanals bzw. einer Datei erkennen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#err"><tt>ERR</tt></a></td>
    <td>Letzten Fehlercode ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#err$"><tt>ERR$</tt></a></td>
    <td>Letzten Fehlertext ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#hex$"><tt>HEX$</tt></a></td>
    <td>numerischen Wert in eine Hexadezimalzahl umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#hibyte"><tt>HIBYTE</tt></a></td>
    <td>H&ouml;herwertiges Byte ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#h_char"><tt>H_CHAR</tt></a></td>
    <td>
     Bildschirmh&ouml;he in Zeichenpositionen (Anzahl Textzeilen) ermitteln
    </td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#h_pixel"><tt>H_PIXEL</tt></a></td>
    <td>Bildschirmh&ouml;he in Pixel ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#in"><tt>IN</tt></a></td>
    <td>Wert von einem Eingabetor lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#inkey$"><tt>INKEY$</tt></a></td>
    <td>Tastaturstatus abfragen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#in"><tt>INP</tt></a></td>
    <td>Wert von einem Eingabetor lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#input$"><tt>INPUT$</tt></a></td>
    <td>
     Tastatureingaben ohne Echo oder Bytes aus einem Eingabekanal
     bzw. einer Datei lesen
    </td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#instr"><tt>INSTR</tt></a></td>
    <td>Zeichenkette in einer anderen Zeichenkette suchen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#is_target"><tt>IS_TARGET</tt></a></td>
    <td>Testen auf ein Zielsystem</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#joyst"><tt>JOYST</tt></a></td>
    <td>Joystick abfragen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#lcase$"><tt>LCASE$</tt></a></td>
    <td>Zeichenkette in Kleinbuchstaben wandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#left$"><tt>LEFT$</tt></a></td>
    <td>Anfang einer Zeichenkette extrahieren</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#len"><tt>LEN</tt></a></td>
    <td>L&auml;nge einer Zeichenkette ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#lobyte"><tt>LOBYTE</tt></a></td>
    <td>Niederwertiges Byte ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#lower$"><tt>LOWER$</tt></a></td>
    <td>Zeichenkette in Kleinbuchstaben wandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ltrim$"><tt>LTRIM$</tt></a></td>
    <td>F&uuml;hrende wei&szlig;e Leerzeichen abschneiden</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#max"><tt>MAX</tt></a></td>
    <td>Gr&ouml;&szlig;ter Wert aus einer Liste von Werten ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#memstr$"><tt>MEMSTR$</tt></a></td>
    <td>auf eine im Arbeitsspeicher liegende Zeichenkette zugreifen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#mid$"><tt>MID$</tt></a></td>
    <td>Teilzeichenkette aus einer Zeichenkette extrahieren</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#min"><tt>MIN</tt></a></td>
    <td>Kleinster Wert aus einer Liste von Werten ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#mirror$"><tt>MIRROR$</tt></a></td>
    <td>Zeichenkette spiegeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#peek"><tt>PEEK</tt></a></td>
    <td>8-Bit-Wert (1&nbsp;Byte) aus dem Arbeitsspeicher lesen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#point"><tt>POINT</tt></a></td>
    <td>Farbe eines Pixels ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ptest"><tt>PTEST</tt></a></td>
    <td>Testen eines Pixels</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#right$"><tt>RIGHT$</tt></a></td>
    <td>Ende einer Zeichenkette extrahieren</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#rnd"><tt>RND</tt></a></td>
    <td>Ermitteln einer Zufallszahl</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#rtrim$"><tt>RTRIM$</tt></a></td>
    <td>angeh&auml;ngte wei&szlig;e Leerzeichen abschneiden</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#sgn"><tt>SGN</tt></a></td>
    <td>Ermitteln des Vorzeichens</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#space$"><tt>SPACE$</tt></a></td>
    <td>mit Leerzeichen gef&uuml;llte Zeichenkette erzeugen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#sqr"><tt>SQR</tt></a></td>
    <td>Ermitteln der Quadratwurzel</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#str$"><tt>STR$</tt></a></td>
    <td>numerischen Wert in eine Dezimalzahl umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#string$"><tt>STRING$</tt></a></td>
    <td>Zeichen oder Zeichenkette vervielf&auml;ltigen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#trim$"><tt>TRIM$</tt></a></td>
    <td>wei&szlig;e Leerzeichen abschneiden</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ucase$"><tt>UCASE$</tt></a></td>
    <td>Zeichenkette in Gro&szlig;buchstaben wandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ucase$"><tt>UPPER$</tt></a></td>
    <td>Zeichenkette in Gro&szlig;buchstaben wandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#usr"><tt>USR</tt></a></td>
    <td>In Maschinencode implementierte Funktion aufrufen</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#val"><tt>VAL</tt></a></td>
    <td>Zeichenkette in einen numerischen Wert umwandeln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#w_char"><tt>W_CHAR</tt></a></td>
    <td>
     Bildschirmbreite in Zeichenpositionen (Anzahl Textspalten) ermitteln
    </td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#w_pixel"><tt>W_PIXEL</tt></a></td>
    <td>Bildschirmbreite in Pixel ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#xpos"><tt>XPOS</tt></a></td>
    <td>aktuelle X-Koordinate des Grafikcursors ermitteln</td>
   </tr>
   <tr valign="top">
    <td><a href="functions.htm#ypos"><tt>YPOS</tt></a></td>
    <td>aktuelle Y-Koordinate des Grafikcursors ermitteln</td>
   </tr>
  </table>
 <br/><br/>

 <h3><a name="func_descr">5. Beschreibung Funktionen</a></h3>
  In spitzen Klammern eingeschlossene Elemente dienen als Platzhalter
  und sind entsprechend zu ersetzten.
 <br/><br/>

 <h3><a name="abs">ABS</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>ABS</tt> <tt>(</tt> &lt;numerischer Ausdruck&gt; <tt>)</tt></td>
   </tr>
  </table>
 <br/>
   Die Funktion liefert den absoluten Betrag des Wertes
   des angegebenen Ausdrucks.
 <br/><br/>

 <h3><a name="asc">ASC</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>ASC (</tt> &lt;Zeichenkette&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
   Die Funktion liefert den Code des ersten Zeichens
   in der &uuml;bergebenen Zeichenkette.
   Ist die Zeichenkette leer, wird 0 zur&uuml;ckgegeben.
 <br/><br/>

 <h3><a name="asm">ASM</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td nowrap="nowrap">
     <tt>ASM (</tt> &lt;Zeichenkette&gt;
     [, &lt;Zeichenkette&gt; [, ...]] <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>String-Literal</td></tr>
  </table>
 <br/>
  Die ASM-Funktion f&uuml;gt in den vom Compiler erzeugten Assemblertext
  eine oder mehrere Assemblerzeilen ein.
  Im Gegensatz zur <a href="instructions.htm#asm">ASM</a>-Anweisung
  wird bei der ASM-Funktion der Wert im HL-Register an das BASIC-Programm
  zur&uuml;ckgegeben.
  In Verbindung mit der <a href="functions.htm#memstr$">MEMSTR$</a>-Funktion
  lassen sich auch in eigenen Assembler-Routinen
  erzeugte Zeichenketten an das BASIC-Programm zur&uuml;ckgeben.
 <br/><br/>
  Das Beispiel zeigt eine m&ouml;gliche Anwendung der ASM-Funktion
  in Verbindung mit <a href="functions.htm#usr">USR</a>,
  um auf diese Art und Weise einen Parameter an die Assembler-Routine
  zu &uuml;bergeben und einen numerischen Wert zur&uuml;ckgeben zu lassen:
 <br/>
  <tt>
   &#10;<br/>
   DEF USR0 = ASM(" LD HL,meine_negation")&#10;<br/>
   PRINT USR0(123)&#10;<br/>
   END&#10;<br/>
   &#10;<br/>
   ASM "meine_negation:"&#10;<br/>
   ASM " LD HL,0000H"&#10;<br/>
   ASM " OR A"&#10;<br/>
   ASM " SBC HL,DE"&#10;<br/>
   ASM " RET"&#10;<br/>
  </tt>
 <br/>
  Im zweiten Beispiel liefert die Assembler-Routine die Zeichenkette
  <em>ABC</em> zur&uuml;ck:
 <br/>
  <tt>
   &#10;<br/>
   PRINT MEMSTR$( ASM(" CALL meine_routine") )&#10;<br/>
   END&#10;<br/>
   &#10;<br/>
   ASM CODE "meine_routine:"&#10;<br/>
   ASM CODE " LD HL,mein_string"&#10;<br/>
   ASM CODE " RET"&#10;<br/>
   ASM DATA "mein_string: DB 'ABC',0"&#10;<br/>
  </tt>
 <br/>
  <b>Achtung!</b> Der BASIC-Compiler enth&auml;lt einen Global-Optimizer,
  der den erzeugten Assembler-Code durchgeht und unn&ouml;tige Befehle
  entfernt.
  Dabei kann auch der mit ASM-Funktionen erzeugte Assembler-Code
  ver&auml;ndert werden.
  Der Global-Optimizer fasst aber nur solche Assembler-Zeilen an,
  bei denen die Befehls-Memonik durch einen Tabulator vom Zeilenanfang
  bzw. der Marke getrennt ist.
  Wenn sie also sichergehen wollen, dass der Optimizer Ihren
  Assembler-Code nicht ver&auml;ndert,
  dann verwenden Sie keine Tabulatoren in den ASM-Funktionen.
 <br/><br/>
  <b>Achtung!</b> Die ASM-Funktion greift direkt
  in die Programmcodeerzeugung ein und ist deshalb nur
  f&uuml;r Experten gedacht, die genau wissen, was sie tun!
 <br/><br/>

 <h3><a name="bin$">BIN$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>BIN$</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt><br/>
     <tt>BIN$</tt> <tt>(</tt> &lt;Wert&gt;
	<tt>,</tt> &lt;Anzahl Stellen&gt; <tt>)</tt><br/>
    </td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Anzahl Stellen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion BIN$ erzeugt eine Zeichenkette,
  die den &uuml;bergebenen Wert als Bin&auml;rzahl darstellt.
  Wird das zweite Argument weggelassen oder dieses ist&nbsp;0,
  dann richtet sich die Anzahl der Stellen,
  d.h. die L&auml;nge der erzeugten Zeichenkette,
  nach der Gr&ouml;&szlig;e des &uuml;bergebenen Wertes.
 <br/><br/>

 <h3><a name="chr$">CHR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>CHR$</tt> <tt>(</tt> &lt;Zeichencode&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichencode:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion CHR$ erzeugt eine Zeichenkette,
  die nur aus dem einen Zeichen besteht,
  welches dem &uuml;bergebenen Zeichencode
  (i.d.R.&nbsp;ASCII-Code) entspricht.
  Wird der Wert&nbsp;0 &uuml;bergeben, ist die zur&uuml;ckgelieferte
  Zeichenkette leer.
 <br/><br/>
  <b>Achtung!</b> Bei den Anweisungen
  <a href="instructions.htm#print">PRINT</a> und
  <a href="instructions.htm#lprint">LPRINT</a> wird mit <tt>CHR$(0)</tt>
  ein Nullbyte ausgegeben.
 <br/><br/>

 <h3><a name="deek">DEEK</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td> <tt>DEEK</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt></td>
   </tr>
   <tr valign="top">
    <td>Adresse:</td><td>numerischer Ausdruck</td>
   </tr>
  </table>
 <br/>
  Die Funktion liest zwei aufeinander folgende Bytes vom Arbeitsspeicher
  ab der angegebenen Adresse und liefert sie als 16-Bit-Wert zur&uuml;ck.
 <br/><br/>

 <h3><a name="eof">EOF</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>EOF</tt> <tt>(</tt> &lt;Kanal&gt; <tt>)</tt><br/>
     <tt>EOF</tt> <tt>( #</tt> &lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion testet,
  ob das Ende des Eingabekanals bzw. der Datei erreicht wurde.
  Dabei werden die Fehlervariablen&nbsp;<a href="functions.htm#err">ERR</a>
  und <a href="functions.htm#err$">ERR$</a> gesetzt.
 <br/><br/>
  Bei Dateien liefert die Funktion erst dann sicher
  <a href="constants.htm#boolean">TRUE</a> zur&uuml;ck,
  wenn versucht wurde, &uuml;ber das Dateiende hinaus zu lesen.
 <br/><br/>

 <h3><a name="err">ERR</a></h3>
  Die Systemvariable ERR enth&auml;lt den letzten Fehlercode.
  Der Wert&nbsp;0 (Konstante&nbsp;E_OK) bedeutet,
  dass bei der letzten Anweisung oder Funktion,
  die die Fehlervariable gesetzt hat, kein Fehler aufgetreten ist.
  Ein Wert ungleich&nbsp;0 steht f&uuml;r einen Fehler.
  Zum Auswerten der Fehlervariable&nbsp;ERR gibt es
  <a href="constants.htm#error">Fehlercodekonstanten</a>.
 <br/><br/>

 <h3><a name="err$">ERR$</a></h3>
  Die Systemvariable ERR$ enth&auml;lt den letzten Fehlertext.
  In Verbindung mit der Systemvariable&nbsp;ERR
  kann die Fehlerbehandlung recht einfach und f&uuml;r den Anwender
  trotzdem komfortabel gestaltet werden, z.B.:
 <br/>
  <tt>
   &#10;<br/>
   ...:'Funktion oder Anweisung, die die Fehlervariablen setzt&#10;<br/>
   IF ERR THEN&#10;<br/>
   &nbsp;&nbsp;PRINT ERR$&#10;<br/>
   ELSE&#10;<br/>
   &nbsp;&nbsp;...:'kein Fehler aufgetreten&#10;<br/>
   ENDIF&#10;<br/>
  </tt>
 <br/>
  <b>Achtung!</b> Wenn Sie die Systemvariable&nbsp;ERR$ verwenden,
  wird das compilierte Programm entsprechend gr&ouml;&szlig;er,
  da alle Fehlermeldungen, die auftreten k&ouml;nnen,
  auch in das Programm hineincompiliert werden m&uuml;ssen.
  Wenn Sie ein m&ouml;glichst kleines Programm anstreben
  und auf die detaillierten Fehlertexte verzichten k&ouml;nnen,
  sollten Sie nur die Fehlercodevariable&nbsp;ERR auswerten
  und ERR$ nicht verwenden.
 <br/><br/>

 <h3><a name="hex$">HEX$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>HEX$</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt><br/>
     <tt>HEX$</tt> <tt>(</tt> &lt;Wert&gt;
	<tt>,</tt> &lt;Anzahl Stellen&gt; <tt>)</tt><br/>
    </td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Anzahl Stellen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion HEX$ erzeugt eine Zeichenkette,
  die den &uuml;bergebenen Wert als Hexadezimalzahl darstellt.
  Wird das zweite Argument weggelassen oder dieses ist&nbsp;0,
  dann richtet sich die Anzahl der Stellen,
  d.h. die L&auml;nge der erzeugten Zeichenkette,
  nach der Gr&ouml;&szlig;e des &uuml;bergebenen Wertes.
 <br/><br/>

 <h3><a name="hibyte">HIBYTE</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>HIBYTE</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion liefert vom &uuml;bergebenen Wert nur
  den Wert des h&ouml;herwertigen Bytes zur&uuml;ck,
  d.h., der R&uuml;ckgabewert liegt immer im Bereich 0 bis 255.
 <br/><br/>
  Die Funktion HIBYTE hat die gleiche Wirkung wie
  <tt>(&lt;Wert&gt;&nbsp;SHR&nbsp;8)&nbsp;AND&nbsp;&amp;H00FF</tt>,
  erzeugt aber k&uuml;rzeren und schnelleren Programmcode.
 <br/><br/>

 <h3><a name="h_char">H_CHAR</a></h3>
  Die Systemvariable enth&auml;lt die H&ouml;he des Bildschirms
  in Zeichenpositionen, d.h.,
  es wird die Anzahl der sichtbaren Textzeilen zur&uuml;ckgeliefert.
  Wenn dieser Wert nicht eindeutig feststeht bzw. bei dem Zielsystem
  unterschiedliche Werte m&ouml;glich sind (z.B. bei CP/M),
  enth&auml;lt die Variable den Wert&nbsp;-1.
 <br/><br/>
  Eine&nbsp;0 wird zur&uuml;ckgegeben, wenn mit der
  <a href="instructions.htm#screen">SCREEN</a>-Anweisung
  ein Grafikbildschirm eingestellt wurde,
  der keine Textausgaben zul&auml;sst.
 <br/><br/>

 <h3><a name="h_pixel">H_PIXEL</a></h3>
  Diese Systemvariable enth&auml;lt die H&ouml;he
  des vollgrafikf&auml;higen Bildschirms in Pixel.
  Steht keine Vollgrafik zur Verf&uuml;gung,
  wird der Wert&nbsp;0 zur&uuml;ckgegeben.
  In dem Fall k&ouml;nnen die Grafikbefehle nicht verwendet werden.
 <br/><br/>

 <h3><a name="inkey$">INKEY$</a></h3>
  Die Funktion pr&uuml;ft, ob gerade eine Taste gedr&uuml;ckt ist.
  Wenn ja, liefert die Funktion eine Zeichenkette mit dem eingegebenen
  Zeichen zur&uuml;ck.
  Anderenfalls wird eine leere Zeichenkette zur&uuml;ckgegeben.
  INKEY$ hat keine Argumente.
 <br/><br/>

 <h3><a name="in">IN<br/>INP</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>IN</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt><br/>
     <tt>INP</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top"><td>Adresse:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktionen IN und INP lesen ein Byte von dem durch die Adresse
  angegebenen Eingabetor und liefern den Wert des Bytes zur&uuml;ck.
 <br/><br/>
  Beide Funktionen sind identisch. Aus Gr&uuml;nden der Kompatibilit&auml;t
  zu diversen BASIC-Dialekten werden beide Funktionsnamen unterst&uuml;tzt.
 <br/><br/>
  <b>Achtung!</b> Obwohl der Mikroprozessor offiziell nur
  8&nbsp;Bit gro&szlig;e Ein-/Ausgabeadressen unterst&uuml;tzt,
  ist die Nutzung von 16-Bit-Adressen m&ouml;glich.
  Der Compiler &uuml;bersetzt die Anweisung in solch einen Programmcode,
  der aufgrund des undokumentierten Verhaltens des Mikroprozessors
  auch eine 16&nbsp;Bit gro&szlig;e Ein-/Ausgabeadresse
  wirksam werden l&auml;sst.
 <br/><br/>

 <h3><a name="input$">INPUT$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>INPUT$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>)</tt><br/>
     <tt>INPUT$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>,</tt>
		&lt;Kanal&gt; <tt>)</tt><br/>
     <tt>INPUT$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>, #</tt>
		&lt;Kanal&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Anzahl:</td>
    <td>numerischer Ausdruck im Bereich 0 bis 255</td>
   </tr>
   <tr valign="top">
    <td>Kanal:</td>
    <td>numerischer Ausdruck mit dem Wert 1 oder 2</td>
   </tr>
  </table>
 <br/>
  Die Funktion gibt es in zwei Varianten, mit und ohne Kanalnummer.
  In der Variante ohne Kanalnummer wird die angegebene Anzahl von Zeichen
  von der Tastatur gelesen und als Zeichenkette zur&uuml;ckgegeben.
  Steuertasten (z.B. Cursor-Tasten, Enter) werden nicht ausgewertet.
  Stattdessen finden sich die entsprechenden Steuercodes
  in der Zeichenkette wieder.
  Es erfolgt keine Ausgabe auf dem Bildschirm.
 <br/><br/>
  In der Variante mit Kanalnummer liest die Funktion
  die angegebene Anzahl von Zeichen aus dem Eingabekanal
  bzw. der Datei und gibt diese als Zeichenkette zur&uuml;ck.
  Dabei werden die Fehlervariablen <a href="functions.htm#err">ERR</a>
  und <a href="functions.htm#err$">ERR$</a> gesetzt.
 <br/><br/>
  <b>Achtung!</b> Nullbytes dienen bei Zeichenketten als Endezeichen,
  d.h., wenn ein Nullbyte gelesen wird, enth&auml;lt die
  zur&uuml;ckgelieferte Zeichenkette nur die Bytes bis zum ersten
  gelesenen Nullbyte.
  Es werden aber trotzdem soviele Bytes aus dem Eingabekanal gelesen,
  wie im ersten Argument &uuml;bergeben wurde.
  Wenn also die zur&uuml;ckgelieferte Zeichenkette k&uuml;rzer ist
  als die Anzahl der gelesenen Bytes und in der Fehlervariable
  <a href="functions.htm#err">ERR</a> steht der Wert&nbsp;0
  (Konstante E_OK, kein Fehler aufgetreten),
  dann wurde hinter der Zeichenkette ein Nullbyte gelesen.
  Damit ist auch generell das Lesen von Bin&auml;rdateien m&ouml;glich.
  Das Beispiel zeigt, wie eine Datei Byte f&uuml;r Byte eingelesen
  und als Hex-Dump auf dem Bildschirm ausgegeben wird:
 <br/>
  <tt>
   &#10;<br/>
   INPUT "Datei:";F$&#10;<br/>
   OPEN F$ FOR BINARY INPUT AS #1&#10;<br/>
   IF ERR THEN&#10;<br/>
   &nbsp;&nbsp;PRINT ERR$&#10;<br/>
   ELSE&#10;<br/>
   &nbsp;&nbsp;N=0&#10;<br/>
   &nbsp;&nbsp;WHILE NOT EOF(#1)&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;B=ASC(INPUT$(1,#1))&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;IF ERR THEN&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRINT ERR$:EXIT&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;ELSE&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRINT CHR$(32);HEX$(B,2);&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N=N+1&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF N=8 THEN N=0:PRINT&#10;<br/>
   &nbsp;&nbsp;&nbsp;&nbsp;ENDIF&#10;<br/>
   &nbsp;&nbsp;WEND&#10;<br/>
   &nbsp;&nbsp;PRINT&#10;<br/>
   &nbsp;&nbsp;IF ERR THEN PRINT ERR$&#10;<br/>
   &nbsp;&nbsp;CLOSE #1&#10;<br/>
   ENDIF&#10;<br/>
  </tt>
 <br/>

 <h3><a name="instr">INSTR</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>INSTR</tt> <tt>(</tt> &lt;durchsuchte Zeichenkette&gt;
	<tt>,</tt> &lt;gesuchte Zeichenkette&gt; <tt>)</tt><br/>
     <tt>INSTR</tt> <tt>(</tt> &lt;Position&gt;
	<tt>,</tt> &lt;durchsuchte Zeichenkette&gt;
	<tt>,</tt> &lt;gesuchte Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr>
    <td>Position:</td>
    <td>numerischer Ausdruck</td>
   </tr>
   <tr>
    <td>durchsuchte Zeichenkette:</td>
    <td>einfacher String-Ausdruck</td>
   </tr>
   <tr>
    <td>gesuchte Zeichenkette:</td>
    <td>einfacher String-Ausdruck</td>
   </tr>
  </table>
 <br/>
  Die Funktionen sucht in der ersten &uuml;bergebenen Zeichenkette
  die zweite &uuml;bergebene Zeichenkette und gibt die Position
  der Fundstelle zur&uuml;ck.
  Ist die zweite Zeichenkette in der ersten nicht enthalten,
  wird 0 zur&uuml;ckgegeben.
  Wenn eine Position angegeben wurde, wird ab dieser Position gesucht.
 <br/><br/>
  Beispiele:
 <br/><br/>
  <tt>PRINT INSTR("ABCD","C")</tt>
 <br/><br/>
  liefert&nbsp;3.
 <br/><br/>
  <tt>PRINT INSTR(3,"KASKADE","K")</tt>
 <br/><br/>
  liefert&nbsp;4.
 <br/><br/>
  <b>Achtung!</b> Bei dieser Funktion gibt es zwischen den einzelnen
  BASIC-Dialekten Unterschiede in der Argumentreihenfolge.
  Bei den meisten der international &uuml;blichen BASIC-Dialekte
  ist die erste Zeichenkette die durchsuchte
  und die zweite die gesuchte Zeichenkette.
  Aus diesem Grund ist das auch im JKCEMU so realisiert.
  Beim KC-BASIC ist es dagegen genau anders herum.
  Wenn Sie also KC-BASIC-Programme compilieren bzw. portieren m&ouml;chten,
  m&uuml;ssen Sie die beiden Zeichenketten vertauschen.
 <br/><br/>

 <h3><a name="is_target">IS_TARGET</a></h3>
  Die Funktion IS_TARGET ermittelt,
  ob das Programm f&uuml;r ein bestimmtes Zielsystem compiliert wurde.
  Damit kann man BASIC-Programme portabel schreiben und diese
  trotzdem auf ganz spezifische Eigenheiten des Zielsystems anpassen.
  Man ruft die Funktion &uuml;blicherweise mit einer
  <a href="constants.htm#target">Konstante f&uuml;r das Zielsystem</a>
  auf.
  Folgendes Beispiel demonstriert die Anwendung:
 <br/>
  <tt>
   &#10;<br/>
   IF IS_TARGET(TARGET_KC85) THEN PRINT "Ich bin ein KC85/2..5 oder HC900"&#10;<br/>
   IF IS_TARGET(TARGET_Z9001) THEN PRINT "Ich bin ein KC85/1, KC87 oder Z9001"&#10;<br/>
   IF IS_TARGET(TARGET_Z1013) THEN PRINT "Ich bin ein Z1013"&#10;<br/>
  </tt>
 <br/>
  <b>Achtung!</b> Die Funktion IS_TARGET liefert auch dann
  <a href="constants.htm#boolean">TRUE</a>,
  wenn f&uuml;r ein abgeleitetes Zielsystem compiliert wird
  und man auf das allgemeinere Zielsystem testet,
  d.h., wenn z.B. in den Compiler-Optionen das Zielsystem
  <em>TARGET_KC85_4</em> (KC85/4..5 mit Unterst&uuml;tzung beider Bildspeicher)
  eingestellt ist, liefert die Funktion sowohl bei
  <em>TARGET_KC85</em> als auch bei <em>TARGET_KC85_4</em> TRUE.
 <br/><br/>
  <b>Achtung!</b> Die Funktion IS_TARGET ermittelt nicht,
  auf welchem Computertyp das Programm tats&auml;chlich ausgef&uuml;hrt wird,
  sondern f&uuml;r welchen Computertyp das BASIC-Programm compiliert wurde.
  So kann z.B. ein Programm f&uuml;r den AC1 &uuml;bersetzt werden,
  aber trotzdem auf einem LLC2 ausgef&uuml;hrt werden,
  wenn es keine AC1-spezifischen Dinge verwendet.
  Die Funktion IS_TARGET(TARGET_AC1) w&uuml;rde dann trotzdem TRUE
  und IS_TARGET(TARGET_LLC2) FALSE liefern.
 <br/><br/>

 <h3><a name="joyst">JOYST</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>JOYST</tt> <tt>(</tt> &lt;Joystick-Nummer&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>Joystick-Nummer:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
  </table>
 <br/>
  Die Funktionen liest den aktuellen Status des angegebenen Joysticks.
  Der erste Joystick hat die Nummer&nbsp;0.
  Die Bit-Belegung des R&uuml;ckgabewertes unterscheidet sich zwischen
  den einzelnen <a href="targets.htm">Zielsystemen</a> und sollte deshalb
  mit folgenden Konstanten ausgewertet werden:
 <br/><br/>
  <table border="1">
   <tr><th>Konstante</th><th>Bedeutung</th></tr>
   <tr>
    <td><tt>JOYST_LEFT</tt></td>
    <td>Joystick nach links gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td><tt>JOYST_RIGHT</tt></td>
    <td>Joystick nach rechts gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td><tt>JOYST_UP</tt></td>
    <td>Joystick nach oben gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td><tt>JOYST_DOWN</tt></td>
    <td>Joystick nach unten gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td><tt>JOYST_BUTTON1</tt></td>
    <td>Aktionsknopf&nbsp;1 gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td><tt>JOYST_BUTTON2</tt></td>
    <td>Aktionsknopf&nbsp;2 gedr&uuml;ckt</td>
   </tr>
   <tr>
    <td><tt>JOYST_BUTTONS</tt></td>
    <td>Aktionsknopf&nbsp;1 oder 2 gedr&uuml;ckt</td>
   </tr>
  </table>
 <br/>
  Die JOYST-Funktion liefert einen numerischen Wert zur&uuml;ck,
  bei der jedes gesetzte Bit f&uuml;r eine bestimmte Aktion steht.
  Dabei k&ouml;nnen mehrere Bits gleichzeitig gesetzt sein,
  z.B. die Bits f&uuml;r links und nach oben,
  wenn der Joystick nach links oben gedr&uuml;ckt wird.
  Die Joystick-Konstanten sind so definiert,
  dass das jeweilige Bit der betreffenden Aktion gesetzt ist.
  Mit Hilfe der
  <a href="expressions.htm#operators2">AND</a>-Verkn&uuml;pfung
  k&ouml;nnen die einzelnen Aktionen getestet werden:
 <br/>
  <tt>
   &#10;<br/>
   A=JOYST(0)&#10;<br/>
   IF A AND JOYST_LEFT THEN PRINT "links"&#10;<br/>
   IF A AND JOYST_RIGHT THEN PRINT "rechts"&#10;<br/>
   IF A AND JOYST_DOWN THEN PRINT "ab"&#10;<br/>
   IF A AND JOYST_UP THEN PRINT "auf"&#10;<br/>
   IF A AND JOYST_BUTTON1 THEN PRINT "Feuer 1"&#10;<br/>
   IF A AND JOYST_BUTTON2 THEN PRINT "Feuer 2"&#10;<br/>
   IF A AND JOYST_BUTTONS THEN PRINT "Feuer 1 oder 2"&#10;<br/>
  </tt>
 <br/>
  Auf einem Zielsystem, bei dem nur ein Feuerknopf pro Joystick
  unterst&uuml;tzt wird, hat die Konstante <tt>JOYST_BUTTONS</tt>
  den gleichen Wert wie <tt>JOYST_BUTTON1</tt>
  und <tt>JOYST_BUTTON2</tt> ist&nbsp;0.
  Auf Systemen, die keine Joystick-Unterst&uuml;tzung bieten,
  liefert die JOYST-Funktion immer&nbsp;0
  und die Joystick-Konstanten haben auch alle den Wert&nbsp;0.
 <br/><br/>

 <h3><a name="lcase$">LCASE$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LCASE$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LCASE$ wandelt in der &uuml;bergebenen Zeichenkette
  die gro&szlig;en Buchstaben entsprechend dem ASCII-Zeichensatz
  in kleine um und liefert die umgewandelte Zeichenkette zur&uuml;ck.
  Eventuell vorhandene deutsche Umlaute bleiben unver&auml;ndert.
 <br/><br/>
  LCASE$ ist identisch zur Funktion LOWER$.
  Aus Gr&uuml;nden der Kompatibilit&auml;t zu diversen BASIC-Dialekten
  werden beide Funktionsnamen unterst&uuml;tzt.
 <br/><br/>

 <h3><a name="left$">LEFT$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LEFT$</tt> <tt>(</tt> &lt;Zeichenkette&gt;
	<tt>,</tt> &lt;Anzahl Zeichen&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr><td>Anzahl Zeichen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LEFT$ extrahiert aus der &uuml;bergebenen Zeichenkette
  eine Teilzeichenkette, die aus den linken <em>Anzahl Zeichen</em> besteht.
 <br/><br/>

 <h3><a name="len">LEN</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LEN</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion liefert die L&auml;nge der &uuml;bergebenen Zeichenkette
  zur&uuml;ck.
 <br/><br/>
  <b>Achtung!</b> Bei Zeichenketten, die mehr als 32767&nbsp;Zeichen
  enthalten, ist der R&uuml;ckgabewert kleiner&nbsp;0!
  Die interne String-Verarbeitung kann zwar so lange Zeichenketten nicht
  erzeugen, aber mit der Funktion
  <a href="functions.htm#memstr$">MEMSTR$</a> sind &uuml;berlange
  Zeichenketten prinzipiell m&ouml;glich.
 <br/><br/>

 <h3><a name="lobyte">LOBYTE</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>LOBYTE</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion liefert vom &uuml;bergebenen Wert nur
  den Wert des niederwertigen Bytes zur&uuml;ck,
  d.h., der R&uuml;ckgabewert liegt immer im Bereich 0 bis 255.
 <br/><br/>
  Die Funktion LOBYTE hat die gleiche Wirkung wie
  <tt>&lt;Wert&gt;&nbsp;AND&nbsp;&amp;H00FF</tt>,
  erzeugt aber k&uuml;rzeren und schnelleren Programmcode.
 <br/><br/>

 <h3><a name="lower$">LOWER$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LOWER$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LOWER$ wandelt in der &uuml;bergebenen Zeichenkette
  die gro&szlig;en Buchstaben entsprechend dem ASCII-Zeichensatz in kleine um
  und liefert die umgewandelte Zeichenkette zur&uuml;ck.
  Eventuell vorhandene deutsche Umlaute bleiben unver&auml;ndert.
 <br/><br/>
  LOWER$ ist identisch zur Funktion LCASE$.
  Aus Gr&uuml;nden der Kompatibilit&auml;t zu diversen BASIC-Dialekten
  werden beide Funktionsnamen unterst&uuml;tzt.
 <br/><br/>

 <h3><a name="ltrim$">LTRIM$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>LTRIM$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion LTRIM$ liefert eine Teilzeichenkette,
  die mit dem ersten Zeichen beginnt,
  welches kein Leer- oder Steuerzeichen ist.
  Es werden somit die f&uuml;hrenden wei&szlig;en Leerzeichen abgeschnitten.
 <br/><br/>

 <h3><a name="max">MAX</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>MAX</tt>
     <tt>(</tt>
     &lt;numerischer Ausdruck&gt;
     <tt>,</tt>
     &lt;numerischer Ausdruck&gt;
     [ <tt>,</tt> &lt;numerischer Ausdruck&gt; [ , ... ] ]
     <tt>)</tt>
    </td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert den gr&ouml;&szlig;ten der in der Argumentliste
  angegebenen Werte zur&uuml;ck.
 <br/><br/>

 <h3><a name="memstr$">MEMSTR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>MEMSTR$</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Adresse:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion MEMSTR$ erm&ouml;glicht es, eine an der angegebenen Adresse
  im Arbeitsspeicher befindliche Zeichenkette als BASIC-String zu verwenden.
  Ein Nullbyte markiert das Ende der Zeichenkette.
  Folgendes Beispiel erzeugt im Arbeitsspeicher eine Zeichenkette
  mit dem Alphabet, auf die dann mit MEMSTR$ zugegriffen wird:
 <br/>
  <tt>
   &#10;<br/>
   A=TOP&#10;<br/>
   FOR I=65 TO 90&#10;<br/>
   &nbsp;&nbsp;POKE A,I&#10;<br/>
   &nbsp;&nbsp;A=A+1&#10;<br/>
   NEXT I&#10;<br/>
   POKE A,0&#10;<br/>
   PRINT MEMSTR$(TOP)&#10;<br/>
  </tt>
 <br/>

 <h3><a name="mid$">MID$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>MID$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>,</tt>
	&lt;Position&gt; <tt>)</tt><br/>
     <tt>MID$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>,</tt>
	&lt;Position&gt; <tt>,</tt> &lt;Anzahl Zeichen&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr><td>Position:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Anzahl Zeichen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion MID$ extrahiert aus der &uuml;bergebenen Zeichenkette
  ab der angegebenen Position eine Teilzeichenkette
  und liefert diese zur&uuml;ck.
  Wird das dritte Argument angegeben, ist die Teilzeichenkette maximal
  <em>Anzahl Zeichen</em> lang.
  Anderenfalls geht die Teilzeichenkette bis zum Ende der Zeichenkette.
 <br/><br/>

 <h3><a name="min">MIN</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>MIN</tt>
     <tt>(</tt>
     &lt;numerischer Ausdruck&gt;
     <tt>,</tt>
     &lt;numerischer Ausdruck&gt;
     [ <tt>,</tt> &lt;numerischer Ausdruck&gt; [ , ... ] ]
     <tt>)</tt>
    </td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert den kleinsten der in der Argumentliste
  angegebenen Werte zur&uuml;ck.
 <br/><br/>

 <h3><a name="mirror$">MIRROR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>MIRROR$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion MIRROR$ liefert ein gespiegeltes Abbild der
  &uuml;bergebenen Zeichenkette zur&uuml;ck, d.h.,
  das letzte Zeichen in der &uuml;bergebenen Zeichenkette
  ist das erste Zeichen in der zur&uuml;ckgelieferten.
 <br/><br/>

 <h3><a name="peek">PEEK</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>PEEK</tt> <tt>(</tt> &lt;Adresse&gt; <tt>)</tt></td>
   </tr>
   <tr valign="top"><td>Adresse:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion liest das Byte vom Arbeitsspeicher,
  welches auf der angegebenen Adresse steht,
  und liefert den Wert des Bytes zur&uuml;ck.
 <br/><br/>

 <h3><a name="point">POINT</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>POINT</tt> <tt>(</tt> &lt;X&gt; <tt>,</tt> &lt;Y&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>X:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
   <tr valign="top">
    <td>Y:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt die aktuelle Farbe des Pixels.
  Im Fehlerfall, d.h. wenn der angegebene Punkt au&szlig;erhalb
  des Bildschirms liegt oder keine Grafikumgebung vorhanden ist,
  wird -1 zur&uuml;ckgeliefert.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/><br/>
  <b>Achtung!</b> Wenn das BASIC-Programm f&uuml;r ein Zielsystem
  mit Farbunterst&uuml;tzung compiliert aber auf einem Computer
  ohne Farbunterst&uuml;tzung gestartet wird,
  liefert die Funktion falsche Werte zur&uuml;ck,
  da sie die Farbe aus dem nicht vorhandenen Farbspeicher liest.
 <br/><br/>

 <h3><a name="ptest">PTEST</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>PTEST</tt> <tt>(</tt> &lt;X&gt; <tt>,</tt> &lt;Y&gt; <tt>)</tt>
    </td>
   </tr>
   <tr valign="top">
    <td>X:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
   <tr valign="top">
    <td>Y:</td>
    <td>numerischer Ausdruck mit einem Wert &gt;= 0</td>
   </tr>
  </table>
 <br/>
  Die Funktion ermittelt den Zustand eines Pixels.
  Ist das Pixel an der angegebenen Position gesetzt,
  wird 1 zur&uuml;ckgeliefert, bei nicht gesetztem Pixel eine&nbsp;0.
  Im Fehlerfall, d.h. wenn der angegebene Punkt au&szlig;erhalb
  des Bildschirms liegt oder keine Grafikumgebung vorhanden ist,
  wird -1 zur&uuml;ckgeliefert.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/><br/>

 <h3><a name="right$">RIGHT$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>RIGHT$</tt> <tt>(</tt> &lt;Zeichenkette&gt;
	<tt>,</tt> &lt;Anzahl Zeichen&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr><td>Anzahl Zeichen:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion RIGHT$ extrahiert aus der &uuml;bergebenen Zeichenkette
  eine Teilzeichenkette, die aus den rechten <em>Anzahl Zeichen</em> besteht.
 <br/><br/>

 <h3><a name="rnd">RND</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>RND</tt> <tt>(</tt> &lt;Maximalwert&gt; <tt>)</tt></td>
   </tr>
   <tr valign="top">
    <td>Maximalwert:</td>
    <td>numerischer Ausdruck mit Wert &gt;&nbsp;0</td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert einen zuf&auml;lligen Wert zwischen&nbsp;0 (inklusive)
  und dem angegebenen Maximalwert (exklusive).
 <br/><br/>
  Beispiel W&uuml;rfel (Ergebnis 1 bis 6):
 <br/><br/>
  <tt>PRINT "Wuerfelergebnis:";RND(6)+1</tt>
 <br/><br/>

 <h3><a name="rtrim$">RTRIM$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>RTRIM$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion RTRIM$ schneidet von der &uuml;bergebenen Zeichenkette
  am Ende stehende Leer- oder Steuerzeichen ab und liefert die so
  eventuell gek&uuml;rzte Zeichenkette zur&uuml;ck.
  Es werden somit die angeh&auml;ngten wei&szlig;en Leerzeichen abgeschnitten.
 <br/><br/>

 <h3><a name="sgn">SGN</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>SGN</tt> <tt>(</tt> &lt;numerischer Ausdruck&gt; <tt>)</tt></td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert -1 zur&uuml;ck,
  wenn der Wert des angegebenen Ausdrucks kleiner&nbsp;0 ist,
  1 wenn der Wert gr&ouml;&szlig;er&nbsp;0 ist
  und 0, wenn der Wert&nbsp;0 ist.
 <br/><br/>

 <h3><a name="space$">SPACE$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>SPACE$</tt> <tt>(</tt> &lt;Anzahl&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Anzahl:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion SPACE$ erzeugt eine Zeichenkette,
  die aus <em>Anzahl</em> Leerzeichen besteht.
 <br/><br/>

 <h3><a name="sqr">SQR</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>SQR</tt> <tt>(</tt> &lt;numerischer Ausdruck&gt; <tt>)</tt></td>
   </tr>
  </table>
 <br/>
  Die Funktion liefert den ganzzahligen Anteil der Quadratwurzel
  aus dem Wert des angegebenen Ausdrucks zur&uuml;ck.
 <br/><br/>

 <h3><a name="str$">STR$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td><tt>STR$</tt> <tt>(</tt> &lt;Wert&gt; <tt>)</tt></td>
   </tr>
   <tr><td>Wert:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion STR$ erzeugt eine Zeichenkette,
  die den &uuml;bergebenen Wert als Dezimalzahl darstellt.
  Das erste Zeichen der erzeugten Zeichenkette ist entweder
  ein Leer- oder ein Minuszeichen.
 <br/><br/>

 <h3><a name="string$">STRING$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>STRING$</tt> <tt>(</tt> &lt;Anzahl&gt;
	<tt>,</tt> &lt;Zeichencode&gt; <tt>)</tt><br/>
     <tt>STRING$</tt> <tt>(</tt> &lt;Anzahl&gt;
	<tt>,</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Anzahl:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Zeichencode:</td><td>numerischer Ausdruck</td></tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion STRING$ liefert eine Zeichenkette zur&uuml;ck,
  die aus <em>Anzahl</em> Wiederholungen der &uuml;bergebenen Zeichenkette
  bzw. des mit seinem Code &uuml;bergebenen Zeichens besteht.
  Die Anzahl der Wiederholungen wird im ersten Argument &uuml;bergeben
  und kann auch&nbsp;0 sein.
  In dem Fall wird eine leere Zeichenkette zur&uuml;ckgeliefert.
 <br/><br/>

 <h3><a name="trim$">TRIM$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>TRIM$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktion TRIM$ schneidet von der &uuml;bergebenen Zeichenkette
  sowohl am Anfang als auch am Ende stehende Leer- oder Steuerzeichen ab
  und liefert die so eventuell gek&uuml;rzte Zeichenkette zur&uuml;ck.
  Es werden somit die f&uuml;hrenden und angeh&auml;ngten
  wei&szlig;en Leerzeichen abgeschnitten.
 <br/><br/>

 <h3><a name="ucase$">UCASE$<br/>UPPER$</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>UCASE$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt><br/>
     <tt>UPPER$</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
  </table>
 <br/>
  Die Funktionen UCASE$ und UPPER$ wandeln in der &uuml;bergebenen
  Zeichenkette die kleinen Buchstaben entsprechend dem ASCII-Zeichensatz
  in gro&szlig;e um und liefert die umgewandelte Zeichenkette zur&uuml;ck.
  Eventuell vorhandene deutsche Umlaute bleiben unver&auml;ndert.
 <br/><br/>
  Beide Funktionen sind identisch. Aus Gr&uuml;nden der Kompatibilit&auml;t
  zu diversen BASIC-Dialekten werden beide Funktionsnamen unterst&uuml;tzt.
 <br/><br/>

 <h3><a name="usr">USR</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>USR</tt> &lt;Funktionsnummer&gt;
	<tt>(</tt> &lt;Argument&gt; <tt>)</tt>
    </td>
   </tr>
   <tr><td>Funktionsnummer:</td><td>0...9</td></tr>
   <tr><td>Argument:</td><td>numerischer Ausdruck</td></tr>
  </table>
 <br/>
  Mit USR wird eine von 10 m&ouml;glichen Funktionen aufgerufen,
  die der Anwender in Maschinencode frei implementieren kann.
  Die Adresse muss vorher mit der Anweisung
  <a href="instructions.htm#defusr">DEF&nbsp;USR</a>
  festgelegt worden sein.
  Das Argument wird im DE-Register der Benutzerfunktion &uuml;bergeben.
  Die Benutzerfunktion selbst muss mit einem Return-Befehl abgeschlossen
  sein.
  Der Wert, der sich zum Funktionsende im HL-Register befindet,
  wird an das BASIC-Programm zur&uuml;ckgegeben.
 <br/><br/>
  Das Schl&uuml;sselwort <tt>USR</tt> und die Funktionsnummer k&ouml;nnen
  sowohl zusammen als auch getrennt geschrieben werden, z.B.:
 <br/>
  <tt>
   &#10;<br/>
   PRINT USR 0 (123)&#10;<br/>
   PRINT USR0 (123)&#10;<br/>
   PRINT USR 0(123)&#10;<br/>
   PRINT USR0(123)&#10;<br/>
  </tt>
 <br/>
  Im Gegensatz zur <a href="instructions.htm#call">CALL</a>-Anweisung
  kann man bei USR dem Maschinencodeunterprogramm einen Wert &uuml;bergeben
  und einen zur&uuml;ckgeben lassen.
 <br/><br/>

 <h3><a name="val">VAL</a></h3>
  <table border="1">
   <tr valign="top">
    <td>Syntax:</td>
    <td>
     <tt>VAL</tt> <tt>(</tt> &lt;Zeichenkette&gt; <tt>)</tt><br/>
     <tt>VAL</tt> <tt>(</tt> &lt;Zeichenkette&gt;
	<tt>,</tt> &lt;Zahlenbasis&gt; <tt>)</tt><br/>
    </td>
   </tr>
   <tr><td>Zeichenkette:</td><td>einfacher String-Ausdruck</td></tr>
   <tr>
    <td>Zahlenbasis:</td>
    <td>numerischer Ausdruck mit dem Wert 2, 10 oder 16</td>
   </tr>
  </table>
 <br/>
  Die Funktion VAL versucht den Inhalt einer Zeichenkette
  als Zahl zu lesen und liefert deren numerischen Wert zur&uuml;ck.
  Wird eine Zahlenbasis angegeben, erwartet die Funktion entsprechend
  dieses Basis eine Bin&auml;r-, Dezimal- oder Hexadezimalzahl.
  Ohne dem zweiten Argument wird immer eine Dezimalzahl erwartet.
  Zahlen mit einer anderen Basis werden nicht unterst&uuml;tzt.
 <br/><br/>
  Bei Hexadezimalzahlen k&ouml;nnen die Buchstaben A bis F
  sowohl gro&szlig; als auch klein geschrieben sein.
 <br/><br/>
  Die VAL-Funktion setzt die Fehlervariablen
  <a href="functions.htm#err">ERR</a> und
  <a href="functions.htm#err$">ERR$</a>.
  Damit, insbesondere mit der ERR-Variable, kann gepr&uuml;ft werden,
  ob die Funktion erfolgreich war:
  <table border="1">
   <tr><th>ERR-Wert</th><th>Bedeutung</th></tr>
   <tr>
    <td valign="top"><a href="constants.htm#error">E_OK</a></td>
    <td>Zahl konnte gelesen werden</td>
   </tr>
   <tr>
    <td valign="top"><a href="constants.htm#error">E_INVALID</a></td>
    <td>
     ung&uuml;ltige Zeichen gelesen,
     R&uuml;ckgabewert ist&nbsp;0
    </td>
   </tr>
   <tr>
    <td valign="top"><a href="constants.htm#error">E_OVERFLOW</a></td>
    <td>
     numerischer &Uuml;berlauf, d.h. die Zahl ist zu gro&szlig;,
     R&uuml;ckgabewert ist&nbsp;0
    </td>
   </tr>
  </table>
 <br/>
  Das Beispiel zeigt die VAL-Funktion in Verbindung mit der
  Fehlervariable&nbsp;ERR:
 <br/>
  <tt>
   &#10;<br/>
   DO&#10;<br/>
   &nbsp;&nbsp;INPUT "Eingabe:";E$&#10;<br>
   &nbsp;&nbsp;V=VAL(E$,2)&#10;<br/>
   &nbsp;&nbsp;IF ERR=E_OK THEN PRINT "Binaerzahl, Dezimalwert=";V&#10;<br/>
   &nbsp;&nbsp;V=VAL(E$,10)&#10;<br/>
   &nbsp;&nbsp;IF ERR=E_OK THEN PRINT "Dezimalzahl, Dezimalwert=";V&#10;<br/>
   &nbsp;&nbsp;V=VAL(E$,16)&#10;<br/>
   &nbsp;&nbsp;IF ERR=E_OK THEN PRINT "Hexadezimalzahl, Dezimalwert=";V&#10;<br/>
   LOOP&#10;<br/>
  </tt>
 <br/>

 <h3><a name="w_char">W_CHAR</a></h3>
  Die Systemvariable enth&auml;lt die Breite des Bildschirms
  in Zeichenpositionen, d.h.,
  es wird die Anzahl der sichtbaren Textspalten zur&uuml;ckgeliefert.
  Wenn dieser Wert nicht eindeutig feststeht bzw. bei dem Zielsystem
  unterschiedliche Werte m&ouml;glich sind (z.B. bei CP/M),
  enth&auml;lt die Variable den Wert&nbsp;-1.
 <br/><br/>
  Eine&nbsp;0 wird zur&uuml;ckgegeben, wenn mit der
  <a href="instructions.htm#screen">SCREEN</a>-Anweisung
  ein Grafikbildschirm eingestellt wurde,
  der keine Textausgaben zul&auml;sst.
 <br/><br/>

 <h3><a name="w_pixel">W_PIXEL</a></h3>
  Die Systemvariable enth&auml;lt die Breite des vollgrafikf&auml;higen
  Bildschirms in Pixel.
  Steht keine Vollgrafik zur Verf&uuml;gung,
  wird der Wert&nbsp;0 zur&uuml;ckgegeben.
  In dem Fall k&ouml;nnen die Grafikbefehle nicht verwendet werden.
 <br/><br/>

 <h3><a name="xpos">XPOS</a></h3>
  Die Systemvariable enth&auml;lt die aktuelle X-Koordinate
  des Grafikcursors.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/><br/>

 <h3><a name="ypos">YPOS</a></h3>
  Die Systemvariable enth&auml;lt die aktuelle Y-Koordinate
  des Grafikcursors.
  Lesen Sie bitte auch die Hinweise zur
  <a href="graphics.htm">Grafikunterst&uuml;tzung</a>.
 <br/>
</body>
</html>

